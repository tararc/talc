/* Utility functions for type checking */

#include "absyn.h"
#include "synpp.h"
#include "set.h"
#include "tcenv.h"
#include "evexp.h"

prefix Tcutil;
open Tcutil;

open Core;
open List;
open Absyn;
open Synpp;
open Set;
open Tcenv;
open Evexp;

exception TypeErr;

void terr(seg loc, string s) {
  Gcdfec::post_error(Gcdfec::mk_err_elab(loc,s));
}

a impos<a>(string msg) {
  fprintf(tal_stderr,"Error: %s\n",msg);
  fflush(tal_stderr);
  raise TypeErr();
}

void warn(seg sg, string msg) {
  fprintf(tal_stderr,"%s: Warning: %s\n",Gcdfec::string_of_seg(sg),msg);
  fflush(tal_stderr);
}

// used to make empty statements more explicit
#define SKIP ;

// compress out any evars or typedefs
typ compress(typ t) {
  switch (t) {
  case Evar(triple):
    <typ>Opt t2opt = triple.2;
    if (t2opt == null) return t;
    else {
      typ t2 = compress(t2opt.v);
      triple.2 = ^Opt(t2);
      return t2;
    }
  case TypedefType(triple):
    <typ>Opt topt = triple.3;
    if (topt == null) return t;
    else {
      typ t2 = compress(topt.v);
      triple.3 = ^Opt(t2);
      return t2;
    }
  default:
    return t;
  }
}

/* return the "least" kind of a type, where Box <= Reg <= Mem */
static kind typ_kind(typ t) {
  switch (compress(t)) {
  case VoidType: return mem_k;
  case Evar*(k,topt,_): return k;
  case VarType(_): return box_k;
  case EnumType(_): return box_k;
  case XenumType(_): return box_k;
  case PointerType(_): return box_k;
  case IntType*(_,sz,bx):
    return (sz == ^size_of.B4 || bx == ^boxed.Boxed) ? box_k :
      reg_k;
  case BoolType(bx):
    return (bx == ^boxed.Boxed) ? box_k : reg_k;
  case FloatType(bx):
    return (bx == ^boxed.Boxed) ? box_k : reg_k;
  case DoubleType(bx):
    return (bx == ^boxed.Boxed) ? box_k : reg_k;
  case ArrayType*(_,_,ak): 
    return (ak == ^array_kind.TaggedArray) ? box_k : mem_k;
  case FnType(_): return mem_k;
  case TupleType(_): return mem_k;
  case StructType(_): return mem_k;
  case TypedefType*(_,_,topt): 
    return impos(sprintf("typ_kind: typedef found: %s", typ2string(t)));
  case UnionType: return impos("union type");
  }
}

/* return true iff k1 <= k2, where Box <= Reg <= Mem */
static bool kind_leq(kind k1, kind k2) {
  switch (k2) {
  case MemKind: return true;
  case RegKind: return (k1 == reg_k || k1 == box_k);
  case BoxKind: return (k1 == box_k);
  }
}

exception Unify;

/* unify types t1 and t2, returning true iff the unification succeeds */
bool unify(typ t1, typ t2) {
  try {
    unify_it(t1,t2);
    return true;
  } catch {
  case Unify: return false;
  }
}

/* see if evar occurs within t */
static void occurs(typ evar, typ t) {
  switch (compress(t)) {
  case Evar*(_,r,_):
    if (t == evar) raise Unify();
    else if (r != null) occurs(evar,r.v);
  case EnumType*(_,ts): occurslist(evar,ts);
  case PointerType*(t,_,_): occurs(evar,t);
  case ArrayType*(t,_,_): occurs(evar,t);
  case FnType*(tvs,rt,args,varargs): // FIX: OK to ignore binding of type vars?
    occurs(evar,rt);
    for(; args != null; args = args.tl)
      occurs(evar,args.hd.3);
  case TupleType(args):
    for(; args != null; args = args.tl)
      occurs(evar,args.hd.2);
  case StructType*(_,ts): occurslist(evar,ts);
  case TypedefType*(_,ts,topt): occurslist(evar,ts);
  default:
    ; // skip
  }
}
static void occurslist(typ evar, <typ>list ts) {
  for (; ts != null; ts = ts.tl)
    occurs(evar,ts.hd);
}

/* unify two lists of types */
static void unify_list(<typ>list t1, <typ>list t2) {
  try
    List::iter2(unify_it,t1,t2);
  catch {
  case List_mismatch: raise Unify();
  }
}

/* unify two type qualifiers -- raises Unify unless they are the same */
static void unify_tqual(tqual tq1, tqual tq2) {
  if ((tq1.q_const != tq2.q_const) ||
      (tq1.q_volatile != tq2.q_volatile) ||
      (tq1.q_restrict != tq2.q_restrict))
    raise Unify();
}

bool equal_tqual(tqual tq1, tqual tq2) {
  return ((tq1.q_const == tq2.q_const) && (tq1.q_volatile == tq2.q_volatile) &&
	  (tq1.q_restrict == tq2.q_restrict));
}

/* compress a conref */
<a>conref compress_conref<a>(<a>conref x) {
  switch (x.v) {
  case None: return x;
  case Eq(_): return x;
  case Forward(y):
    _ z = compress_conref(y);
    x.v = z.v;
    return z;
  }
}

a conref_val<a>(<a>conref x) {
  switch (compress_conref(x).v) {
  case Eq(v): return v;
  default: return impos("conref_val");
  }
}


/* unify two constraint refs */
static void unify_it_conrefs<a>(int cmp(a,a), <a>conref x, <a>conref y) {
  x = compress_conref(x);
  y = compress_conref(y);
  if (x == y) return;
  switch (x.v) {
  case None: x.v = ^constraint.Forward(y);
  case Forward(_): impos("unify_conref: forward after compress");
  case Eq(xv):
    switch (y.v) {
    case None: y.v = x.v;
    case Forward(_): impos("unify_confref: forward after compress(2)");
    case Eq(yv):
      if (cmp(xv,yv) != 0) raise Unify();
    }
  }
}

static bool unify_conrefs<a>(int cmp(a,a), <a>conref x, <a>conref y) {
  try {
    unify_it_conrefs(cmp,x,y);
    return true;
  } catch {
  case Unify: return false;
  }
}

static int cmp_bool(bool x,bool y) {
  if (x == y) return 0;
  if (x == false) return -1;
  return 1;
}

/* the real work of unification */
void unify_it(typ t1, typ t2) {
  t1 = compress(t1);
  t2 = compress(t2);
  if (t1 == t2) return;
  switch (t1) {
  case Evar(triple1):
    _ kind1 = triple1.1;
    _ ref1 = triple1.2;
    // this really shouldn't happen since we compressed t1
    if (ref1 != null)
      return unify_it(ref1.v,t2);
    // check that the evar doesn't occur in t2
    occurs(t1,t2);
    _ kind2 = typ_kind(t2);
    // we can constrain the Evar to be equal to t2 only when the kind of the
    // evar is greater than or equal to the kind of t2 or t2 is an evar that
    // we can constrain to be equal to t1.
    if (kind_leq(kind2,kind1)) {
      triple1.2 = ^Opt(t2);
      return;
    } else {
      switch (t2) {
      case Evar(triple2):
	triple2.2 = ^Opt(t1);
	return;
      default: raise Unify();
      }
    }
  default: // t1 is not an evar
    // in what follows, we raise Unify() unless we explicitly return, hence
    // all of the defaults just skip.
    switch (t2) {
    case Evar(_): // t2 is an evar, t1 is not, swap and try again
      unify_it(t2,t1);
      return;
    case VoidType:
      switch (t1) { case VoidType: return; default: SKIP; }
    case VarType(x):
      switch (t1) {
      case VarType(y): if (strcmp(x,y) == 0) return;
      default: SKIP;
      }
    case EnumType*(nopt2,ts2):
      switch (t1) {
      case EnumType*(nopt1,ts1):
	if ((nopt1 != null && nopt2 != null
             && qvar_cmp(nopt1.v,nopt2.v) == 0) ||
	    (nopt1 == null && nopt2 == null)) {
	  unify_list(ts1,ts2);
	  return;
	}
      default: SKIP;
      }
    case XenumType(n2):
      switch (t1) {
      case XenumType(n1):
        if (qvar_cmp(n1,n2) == 0) return;
      default:
        SKIP;
      }
    case PointerType*(t2,null2,tqual2):
      switch (t1) {
      case PointerType*(t1,null1,tqual1):
	unify_it(t1,t2);
	unify_tqual(tqual1,tqual2);
	unify_it_conrefs(cmp_bool,null1,null2);
	return;
      default:
        ;
      }
    case IntType*(sn2,sz2,bx2):
      switch (t1) {
      case IntType*(sn1,sz1,bx1):
	if ((sn1 == sn2) && (sz1 == sz2) && (bx1 == bx2)) return;
      default: SKIP;
      }
    case BoolType(bx2):
      switch (t1)
	{ case BoolType(bx1): if (bx1 == bx2) return; default: SKIP; }
    case FloatType(bx2):
      switch (t1)
	{ case FloatType(bx1): if (bx1 == bx2) return; default: SKIP; }
    case DoubleType(bx2):
      switch (t1)
	{ case DoubleType(bx1): if (bx1 == bx2) return; default: SKIP; }
    case ArrayType*(t2,tq2,ak2):
      switch (t1) {
      case ArrayType*(t1,tq1,ak1):
	unify_it(t1,t2);
	unify_tqual(tq1,tq2);
	switch (ak1) {
	case UntaggedArray:
	  switch (ak2) { case UntaggedArray: return; default: SKIP; }
	case TaggedArray:
	  switch (ak2) { case TaggedArray: return; default: SKIP; }
	case FixedArray(e1):
	  switch (ak2) {
	  case FixedArray(e2): if (eval_const_uint_exp(e1) ==
				   eval_const_uint_exp(e2)) return;
	  default: SKIP;
	  }
	}
      default: SKIP;
      }
    case FnType*(tvs2,rt2,args2,vararg2):
      switch (t1) {
      case FnType*(tvs1,rt1,args1,vararg1):
	<*(var,typ)>list inst = null;
        while (tvs1 != null) {
	  if (tvs2 == null) raise Unify();
	  inst = ^list(^(tvs2.hd,^typ.VarType(tvs1.hd)),inst);
	  tvs1 = tvs1.tl;
	  tvs2 = tvs2.tl;
	}
	if (tvs2 != null) raise Unify();
        if (inst != null)
          return
            unify_it(^typ.FnType(^(null,rt1,args1,vararg1)),
                     substitute(inst,^typ.FnType(^(null,rt2,args2,vararg2))));
        else {
          unify_it(rt1,rt2);
          for (; args1 != null && args2 != null;
               args1 = args1.tl, args2 = args2.tl) {
            unify_tqual(args1.hd.2,args2.hd.2);
            unify_it(args1.hd.3,args2.hd.3);
          }
          if ((args1 != null) || (args2 != null)) raise Unify();
          if (vararg1 == vararg2) return;
        }
      default: SKIP;
      }
    case TupleType(ts2):
      switch (t1) {
      case TupleType(ts1):
	for (; ts1 != null && ts2 != null; ts1 = ts1.tl, ts2 = ts2.tl) {
	  unify_tqual(ts1.hd.1,ts2.hd.1);
	  unify_it(ts1.hd.2,ts2.hd.2);
	}
	if ((ts1 != null) || (ts2 != null)) raise Unify();
	return;
      default: SKIP;
      }
    case StructType*(nopt2,ts2):
      switch (t1) {
      case StructType*(nopt1,ts1):
	if (((nopt1 == null) && (nopt2 == null)) ||
	    qvar_cmp(nopt1.v,nopt2.v) == 0) {
	  unify_list(ts1,ts2);
          return;
	}
      default: SKIP;
      }
    case TypedefType(_):
      impos(sprintf("unify_it: typedef found: %s",typ2string(t2)));
    case UnionType:
      impos("union type");
    }
    raise Unify();
  }
}

static void unbox_exp(tenv te, exp e) {
  typ t = compress(e.topt.v);
  switch (t) {
  case IntType*(sn,sz,bx):
    if (bx == ^boxed.Boxed)
      unchecked_cast(te,e,^typ.IntType(^(sn,sz,^boxed.Unboxed)));
  case BoolType(bx):
    if (bx == ^boxed.Boxed)
      unchecked_cast(te,e,bool_t);
  case FloatType(bx):
    if (bx == ^boxed.Boxed)
      unchecked_cast(te,e,float_t);
  case DoubleType(bx):
    if (bx == ^boxed.Boxed)
      unchecked_cast(te,e,double_t);
  default: SKIP;
  }
}

/* coerce the list e so that each element has type t -- used in arrays and
   conditionals */
bool coerce_list(tenv te, typ t, <exp>list es) {
  // find the biggest arithmetic type (if any) for the list and determine
  // if all of the elements are boxed.
  <typ>Opt max_arith_type = null;
  bool all_boxed = true;
  for (<exp>list el = es; el != null; el = el.tl) {
    typ t = compress(el.hd.topt.v);
    if (is_arithmetic_type(t)) {
      if (max_arith_type == null || will_lose_precision(t,max_arith_type.v))
	max_arith_type = ^Opt(t);
    }
    if (!is_boxed_type(t)) all_boxed = false;
  }
  // if even one of the expressions is unboxed, then we unbox all of them
  if (!all_boxed && max_arith_type != null)
    max_arith_type = ^Opt(make_unboxed_type(max_arith_type.v));
  // unify the max arithmetic type with the result type t
  if (max_arith_type != null)
    if (!unify(t,max_arith_type.v))
      return false;
  // now coerce each expression to the type t as if by assignment
  for (<exp>list el = es; el != null; el = el.tl) {
    if (!coerce_assign(te,el.hd,t)) {
      exp_err(el.hd.loc,sprintf("type mismatch: expecting %s but found %s",
	      typ2string(t),typ2string(el.hd.topt.v)));
      return false;
    }
  }
  return true;
}

typ make_unboxed_type(typ t) {
  switch (compress(t)) {
  case IntType*(sn,sz,bx):
    return (bx == ^boxed.Unboxed) ? t : ^typ.IntType(^(sn,sz,^boxed.Unboxed));
  case FloatType(_): return Float_t;
  case DoubleType(_): return Double_t;
  case BoolType(_): return Bool_t;
  default: return t;
  }
}

/* coerce e to have type bool -- used in conditionals */
bool coerce_bool_t(tenv te, exp e) {
  if (unify(e.topt.v,bool_t)) return true; // e : bool_t
  if (unify(e.topt.v,Bool_t)) { // e : Bool_t
    unchecked_cast(te,e,bool_t);      // unbox e
    return true;
  }
  return false;
}

/* coerce e to have type unsigned int -- used in subscript */
bool coerce_uint_t(tenv te, exp e) {
  if (unify(e.topt.v,uint_t)) return true;
  // try unboxing e
  if (typ_kind(e.topt.v) == box_k) {
    unbox_exp(te,e);
    if (unify(e.topt.v,uint_t)) return true;
  }
  // try arithmetic conversions -- we only allow integral values
  if (is_integral_type(e.topt.v)) {
    if (will_lose_precision(e.topt.v,uint_t))
      warn(e.loc,"integral size mismatch; conversion supplied");
    unchecked_cast(te,e,uint_t);
    return true;
  }
  return false;
}

/* coerce e to have type t -- used in function call */
bool coerce_arg(tenv te, exp e, typ t2) {
  typ t1 = compress(e.topt.v);
  // see if types immediately match
  if (unify(t1,t2)) return true;
  // try unboxing e
  if (typ_kind(t1) == box_k && typ_kind(t2) == reg_k) {
    unbox_exp(te,e);
    if (unify(t1,t2)) return true;
  }
  // try arithmetic conversions
  if (is_arithmetic_type(t1) && is_arithmetic_type(t2)) {
    // issue a warning if we lose precision
    if (will_lose_precision(t1,t2))
      warn(e.loc,"integral size mismatch; conversion supplied");
    unchecked_cast(te,e,t2);
    return true;
  } else if (silent_castable(te,e.loc,t1,t2)) {
    unchecked_cast(te,e,t2);
    return true;
  } else if (castable(te,e.loc,t1,t2)) {
    unchecked_cast(te,e,t2);
    warn(e.loc,sprintf("implicit cast from %s to %s",typ2string(t1),
		       typ2string(t2)));
    return true;
  } else return false;
}

/* coerce e to have type t -- used in assignment operations.  Neither
   gcc nor VC++ issue warnings for losing precision here, but I think
   it may be appropriate. */
bool coerce_assign(tenv te, exp e, typ t) {
  return coerce_arg(te,e,t);
}

bool is_integral_type(typ t) {
  switch (compress(t)) {
  case IntType(_): return true;
  default: return false;
  }
}

bool is_arithmetic_type(typ t) {
  switch (compress(t)) {
  case IntType(_): return true;
  case FloatType(_): return true;
  case DoubleType(_): return true;
  default: return false;
  }
}

bool is_boxed_type(typ t) {
  switch (compress(t)) {
  case IntType*(_,_,bx): return (bx == ^boxed.Boxed);
  case FloatType(bx): return (bx == ^boxed.Boxed);
  case DoubleType(bx): return (bx == ^boxed.Boxed);
  case BoolType(bx): return (bx == ^boxed.Boxed);
  default: return false;
  }
}

/* we're about to convert a value of type t1 to type t2 -- return true
   if we will potentially loose precision */
bool will_lose_precision(typ t1, typ t2) {
  t1 = compress(t1);
  t2 = compress(t2);
  switch (t1) {
  case DoubleType(_): return (!is_double(t2));
  case FloatType(_):
    switch (t2) {
    case DoubleType(_): return false;
    case FloatType(_): return false;
    default: return true;
    }
  case IntType*(sn1,sz1,_):
    switch (t2) {
    case DoubleType(_): return false;
    case FloatType(_): return (sz1 == ^size_of.B8);
    case IntType*(sn2,sz2,_):
      switch (sz1) {
      case B1: return false;
      case B2: return (sz2 == ^size_of.B1);
      case B4: return (sz2 == ^size_of.B1 || sz2 == ^size_of.B2);
      case B8: return (sz2 != ^size_of.B8);
      }
    default:
      return impos("will_lose_precision");
    }
  default:
    return impos("will_lose_precision");
  }
}


/* Convert e so that it has type t, possibly by casting t.  This is
   used in routines like function call or assignment where we may have
   to promote an integral type, may have to unbox, etc.  -- THIS IS
   NOT RIGHT. */
bool coerce_use(tenv te, exp e, typ t2) {
  typ t1 = compress(e.topt.v);
  kind k1 = typ_kind(t1);
  kind k2 = typ_kind(t2);
  if (k1 == box_k && k2 == reg_k) {
    unbox_exp(te,e);
  }
  if (unify(t1,t2)) return true;
  // unification failed, try unboxing e
  any_promote(te,e);
  if (unify(e.topt.v,t2)) return true;
  else if (silent_castable(te,e.loc,t1,t2)) {
    unchecked_cast(te,e,t2);
    return true;
  } else if (castable(te,e.loc,t1,t2)) {
    unchecked_cast(te,e,t2);
    warn(e.loc,sprintf("implicit cast from %s to %s",typ2string(t1),
		       typ2string(t2)));
    return true;
  } else return false;
}

bool coerceable(typ t) {
  switch (compress(t)) {
  case IntType(_): return true;
  case FloatType(_): return true;
  case DoubleType(_): return true;
  default:
    return false;
  }
}

/* Can t1 be (implicitly) cast to t2? Assumes types are well-formed */
bool silent_castable(tenv te, seg loc, typ t1, typ t2) {
  typ t1 = compress(t1);
  typ t2 = compress(t2);
  switch (t1) {
  case PointerType*(t_a,null_a,q_a):
    // can cast t@ to t* but not vice versa.  can cast a non-const pointer
    // to a const pointer.  can cast a t pointer to a t[],t[1].
    switch (t2) {
    case PointerType*(t_b,null_b,q_b):
      bool okay = true;
      if (!unify_conrefs(cmp_bool,null_a,null_b)) {
	switch (compress_conref(null_a).v) {
	case Eq(b):
	  okay = !b;
	default: impos("silent_castable: conref not eq");
	}
      }
      return (okay && unify(t_a,t_b) && (!q_a.q_const || q_b.q_const));
    default:
      return false;
    }
  case ArrayType*(t1,tq1,ak1):
    switch (t2) {
    case ArrayType*(t2,tq2,ak2):
      bool okay = true;
      switch (ak1) {
      case UntaggedArray:
	okay = (ak2 == ^array_kind.UntaggedArray);
      case TaggedArray:
	okay = 
	  (ak2 == ^array_kind.TaggedArray || ak2 == ^array_kind.UntaggedArray);
      case FixedArray(e1):
	switch (ak2) {
	case FixedArray(e2): 
	  okay = (eval_const_uint_exp(e1) == eval_const_uint_exp(e2));
	default: okay = true;
	}
      }
      return (okay && unify(t1,t2) && (!tq1.q_const || tq2.q_const));
    default: return false;
    }
  default: return unify(t1,t2);
  }
}

// is t1* <= t2*?
//   we flatten t1 and t2 into structurally equivalent tuple types 
//   (and thus ignore field names, associativity of nested tuples and
//   structs, etc.) and then check that t1 is a width extension of t2 
//   and for each field, either (a) both t1 and t2 have qualifier "const"
//   and the t1 field is a subtype of the t2 field, or (b) t1 = t2.
static bool ptrsubtype(tenv te, <*(typ,typ)>list assume, typ t1, typ t2) {
  <*(tqual,typ)>list tqs1 = flatten_typ(te,t1);
  <*(tqual,typ)>list tqs2 = flatten_typ(te,t2);
  for (; tqs2 != null; tqs2 = tqs2.tl, tqs1 = tqs1.tl) {
    if (tqs1 == null) return false;
    tqual tq1 = tqs1.hd.1;
    tqual tq2 = tqs2.hd.1;
    typ t1 = tqs1.hd.2;
    typ t2 = tqs2.hd.2;
    if (tq2.q_const && subtype(te,assume,t1,t2)) continue;
    else if (unify(t1,t2)) continue;
    else return false;
  }
  return true;
}

// Flatten a type into a list of type qualifiers and types for
// use in subtype comparison.
// FIX:  we should recursively flatten tuple and struct types here,
// but doing so is tricky because we have to get the padding and
// alignment right.  This seems to be particularly weird on the
// x86 -- I need to find precise documentation on it before we 
// do this.
static <*(tqual,typ)>list flatten_typ(tenv te,typ t1) {
  t1 = compress(t1);
  switch (t1) {
  case VoidType: return null;
  case TupleType(tqs): 
    // FIX: recursively flatten here
    return tqs;
  case StructType*(tdnopt,ts):
    _ n = tdnopt.v;
    _ sd = lookup_structdecl(te,DUMMYLOC,n);
    _ inst = List::zip(sd.tvs,ts);
    if (sd.fields == null) return ^list(^(empty_tqual(),t1),null);
    *(tqual,typ) f(<*(var,typ)>list inst, *(field_name,tqual,typ) x) {
      return ^(x.2,substitute(inst,x.3));
    };
    // FIX: recursively flatten here
    return List::map_c(f,inst,sd.fields.v);
  default: return ^list(^(empty_tqual(),t1),null);
  }
}

// FIX: the plan is, once we have a context that lets us assume t1 <= t2
// for recursive types, then to do deep subtyping.  
static bool subtype(tenv te, <*(typ,typ)>list assume, typ t1, typ t2) {
  if (unify(t1,t2)) return true;
  for (_ a = assume; a != null; a = a.tl) {
    if (unify(t1,a.hd.1) && unify(t2,a.hd.2)) return true;
  }
  t1 = compress(t1);
  t2 = compress(t2);
  switch (t1) {
  case PointerType*(t_a,null_a,q_a):
    switch (t2) {
    case PointerType*(t_b,null_b,q_b):
      // if t1 is const then t2 must be const
      if (q_a.q_const && !q_b.q_const) return false;
      // if t1 is * then t2 must be *
      if (!unify_conrefs(cmp_bool,null_a,null_b) && 
	  conref_val(null_a) && !conref_val(null_b)) return false;
      return ptrsubtype(te, ^list(^(t1,t2),assume), t_a, t_b);
    default: return false;
    }
  default: return false;
  }
}

/* Can t1 be cast to t2?  Assumes that the types are well-formed. */
bool castable(tenv te, seg loc, typ t1, typ t2) {
  typ t1 = compress(t1);
  typ t2 = compress(t2);
  switch (t1) {
  case EnumType*(name_opt,ts):
    // can cast an enum to an int -- extracts the tag
    _ ed = lookup_enumdecl(te,loc,name_opt.v);
    return (coerceable(t2));
  case PointerType*(t_a,null_a,q_a):
    // can cast t* to t@ and vice versa.  can cast a non-cost pointer
    // to a const pointer.  can cast a t pointer to a t[],t[1], or t[?]
    switch (t2) {
    case PointerType*(t_b,null_b,q_b):
      _ assump = ^list(^(t1,t2),null);
      return (ptrsubtype(te,assump,t_a,t_b) && (!q_a.q_const || q_b.q_const));
    case ArrayType*(t_b,q_b,ak):
      _ assump = ^list(^(t1,t2),null);
      if (!(ptrsubtype(te,assump,t_a,t_b) && (!q_a.q_const || q_b.q_const)))
	return false;
      switch (ak) {
      case FixedArray(exp):
	return (eval_const_uint_exp(exp) == 1);
      default: return true;
      }
    default:
      return false;
    }
  case ArrayType*(t1,tq1,ak1):
    switch (t2) {
    case ArrayType*(t2,tq2,ak2):
      bool okay;
      switch (ak1) {
      case FixedArray(e1):
	switch (ak2) {
	case FixedArray(e2): 
	  okay = (eval_const_uint_exp(e1) == eval_const_uint_exp(e2));
	default: okay = true;
	}
      default: okay = true;
      }
      return (okay && unify(t1,t2) && (!tq1.q_const || tq2.q_const));
    default: return false;
    }
  // can cast a numeric type or bool to any numeric type
  case IntType(_)   : return coerceable(t2);
  case BoolType(_)  : 
    if (coerceable(t2)) return true;
    switch (t2) {
    case BoolType(_): return true;
    default: return false;
    }
  case FloatType(_) : return coerceable(t2);
  case DoubleType(_): return coerceable(t2);
  default: return unify(t1,t2);
  }
}

/* Replace e by a cast of e to t.  The caller must ensure that the
   cast is safe. */
void unchecked_cast(tenv te, exp e, typ t) {
  if (!unify(e.topt.v,t)) {
    exp inner = ^exp{topt = e.topt, raw_exp = e.raw_exp,
		     assigned_to = e.assigned_to, loc = e.loc};
    e.raw_exp = ^raw_exp.Cast(^(t,inner));
    e.topt = ^Opt(t);
  }
}

static bool any_promote(tenv te, exp e) {
  typ old_t = compress(e.topt.v);
  typ t;
  switch (old_t) {
  case IntType*(sn,sz,b):
    switch (sz) {
    case B1:  t = sint_t; // convert to unboxed, signed int
    case B2:  t = sint_t; // convert to unboxed, signed int
    case B4: // make unboxed
      t = (sn == ^sign.Unsigned) ? uint_t : sint_t;
    case B8: // make unboxed
      t = (sn == ^sign.Unsigned) ? ulong_t : slong_t;
    }
  case BoolType(b): unchecked_cast(te,e,bool_t); return false; // make unboxed
  case FloatType(b): t = float_t;   // make unboxed
  case DoubleType(b): t = double_t; // make unboxed
  default: return false;
  }
  unchecked_cast(te,e,t);
  return true;
}

/* for comparison operators, we do not unbox Double and Long Long, but
   rather do a pointer comparison.  However, we issue a warning. */
bool comparison_promote(tenv te, exp e) {
  typ old_t = compress(e.topt.v);
  typ t;
  switch (old_t) {
  case IntType*(sn,sz,b):
    switch (sz) {
    case B1:  t = sint_t; // convert to unboxed, signed int
    case B2:  t = sint_t; // convert to unboxed, signed int
    case B4: // make unboxed
      t = (sn == ^sign.Unsigned) ? uint_t : sint_t;
    case B8:
      if (b == ^boxed.Boxed) {
	warn(e.loc,"pointer comparison of Long Long");
	return false;
      } else return true;
    }
  case BoolType(b):
    unchecked_cast(te,e,bool_t);
    return false; // make unboxed
  case FloatType(b):
    t = float_t; // make unboxed
  case DoubleType(b):
    if (b == ^boxed.Boxed) {
      warn(e.loc,"pointer comparison of Double");
      return false;
    } else return true;
  default:
    return false;
  }
  unchecked_cast(te,e,t);
  return true;
}

/* check that the expression has an arithmetic type and, if it's boxed
   or a size that is smaller than an int, then promote it up to int.
   Note that unsigned char or unsigned short will be promoted to
   signed int.  Otherwise, the sign is preserved. */
bool arithmetic_promote(tenv te, exp e) {
  typ old_t = compress(e.topt.v);
  typ t;
  switch (old_t) {
  case IntType*(sn,sz,b):
    switch (sz) {
    case B1:  t = sint_t; // convert to unboxed, signed int
    case B2:  t = sint_t; // convert to unboxed, signed int
    case B4: // make unboxed
      t = (sn == ^sign.Unsigned) ? uint_t : sint_t;
    case B8: // make unboxed
      t = (sn == ^sign.Unsigned) ? ulong_t : slong_t;
    }
  case FloatType(b):  t = float_t;  // make unboxed
  case DoubleType(b): t = double_t; // make unboxed
  case EnumType(_):   t = sint_t;   // convert to unboxed, signed int
  case Evar(_):
    t = sint_t;
    if (!unify(old_t,t))
      if (!unify(old_t,sInt_t))
	return false;
  default:
    return false;
  }
  unchecked_cast(te,e,t);
  return true;
}


/* Make sure that e has integral type; if it's boxed or a size that is
   smaller than an int, then promote it up to int.  Note that unsigned
   char or unsigned short will be promoted to signed int.  Otherwise,
   the sign is preserved.  */
bool integral_promote(tenv te, exp e) {
  typ old_t = compress(e.topt.v);
  typ t;
  switch (old_t) {
  case IntType*(sn,sz,b):
    switch (sz) {
    case B1:  t = sint_t; // convert to unboxed, signed int
    case B2:  t = sint_t; // convert to unboxed, signed int
    case B4: // make unboxed
      t = (sn == ^sign.Unsigned) ? uint_t : sint_t;
    case B8: // make unboxed
      t = (sn == ^sign.Unsigned) ? ulong_t : slong_t;
    }
  case EnumType(_): t = sint_t; // convert to unboxed, signed int
  case Evar(_):
    t = sint_t;
    if (!unify(old_t,t))
      if (!unify(old_t,sInt_t))
	return false;
  default:
    return false;
  }
  unchecked_cast(te,e,t);
  return true;
}

static bool is_boxed_double(typ t) {
  switch (t) {
  case DoubleType(b): return (b == ^boxed.Boxed);
  default: return false;
  }
}

static bool is_boxed_uint8(typ t) {
  switch (t) {
  case IntType*(sn,sz,bx):
    return (sn == ^sign.Unsigned && sz == ^size_of.B8 && bx == ^boxed.Boxed);
  default: return false;
  }
}

static bool is_boxed_sint8(typ t) {
  switch (t) {
  case IntType*(sn,sz,bx):
    return (sn == ^sign.Signed && sz == ^size_of.B8 && bx == ^boxed.Boxed);
  default: return false;
  }
}

static bool is_double(typ t) {
  switch (t) {
  case DoubleType(_): return true;
  default: return false;
  }
}

static bool is_float(typ t) {
  switch (t) {
  case FloatType(_): return true;
  default: return false;
  }
}

static bool is_uint(size_of s, typ t) {
  switch (t) {
  case IntType*(sn,sz,_): return (sn == ^sign.Unsigned && sz == s);
  default: return false;
  }
}

static bool is_sint(size_of s, typ t) {
  switch (t) {
  case IntType*(sn,sz,_): return (sn == ^sign.Signed && sz == s);
  default: return false;
  }
}

typ max_arithmetic_type(typ t1, typ t2) {
  if (is_double(t1) || is_double(t2))
    return ^typ.DoubleType(^boxed.Unboxed);
  else if (is_float(t1) || is_float(t2))
    return ^typ.FloatType(^boxed.Unboxed);
  else if (is_uint(^size_of.B8,t1) || is_uint(^size_of.B8,t2))
    return ^typ.IntType(^(^sign.Unsigned,^size_of.B8,^boxed.Unboxed));
  else if (is_sint(^size_of.B8,t1) || is_sint(^size_of.B8,t2))
    return ^typ.IntType(^(^sign.Signed,^size_of.B8,^boxed.Unboxed));
  else if (is_uint(^size_of.B4,t1) || is_uint(^size_of.B4,t2))
    return ^typ.IntType(^(^sign.Unsigned,^size_of.B4,^boxed.Unboxed));
  else
    return ^typ.IntType(^(^sign.Signed,^size_of.B4,^boxed.Unboxed));
}

void check_fndecl_valid_type(seg loc,tenv te,fndecl fd) {
  check_unique_tvars(loc,fd.tvs);
  check_valid_type(loc,te,fd.tvs,fd.ret_type);
  for (_ x = fd.args; x != null; x = x.tl)
    check_valid_type(loc,te,fd.tvs,x.hd.3);
}

typ fndecl2typ(fndecl fd) {
  return ^typ.FnType(^(fd.tvs,
                       fd.ret_type,
                       List::map(fun *(<var>Opt,tqual,typ)
                                 f(*(var,tqual,typ) x) {
                                   return ^(^Opt(x.1), x.2, x.3); },
                                 fd.args),
                       fd.varargs));
}

typ substitute(<*(var,typ)>list inst, typ t) {
  switch (compress(t)) {
  case VarType(v):
    try
      return List::assoc_cmp(strcmp,inst,v);
    catch {
    case Not_found: return t;
    }
  case StructType*(no,ts):
    return ^typ.StructType(^(no,substs(inst,ts)));
  case EnumType*(no,ts):
    return ^typ.EnumType(^(no,substs(inst,ts)));
  case PointerType*(t,nullable,tq):
    return ^typ.PointerType(^(substitute(inst,t),nullable,tq));
  case TypedefType*(n,ts,topt):
    // NB: topt is null be cause we compressed
    return ^typ.TypedefType(^(n,substs(inst,ts),topt));
  case ArrayType*(t,tq,eopt):
    return ^typ.ArrayType(^(substitute(inst,t),tq,eopt));
  case FnType*(vs,rtyp,args,varargs):
    for (_ p = vs; p != null; p = p.tl)
      inst = ^list(^(p.hd,^typ.VarType(p.hd)),inst);
    _ p = List::split(List::map(fun *(*(<var>Opt,tqual),typ)
                                f(*(<var>Opt,tqual,typ) y) {
                                  return ^(^(y.1,y.2),y.3);
                                },
                                args));
    _ ts = p.2;
    _ ts2 = substs(inst,ts);
    _ args2 = List::map(fun *(<var>Opt,tqual,typ)
                        f(*(*(<var>Opt,tqual),typ) w) {
                          return ^(w.1.1,w.1.2,w.2);
                        },
                        List::zip(p.1,ts2));
    return ^typ.FnType(^(vs,substitute(inst,rtyp), args2, varargs));
  case TupleType(tqts):
    _ p = List::split(tqts);
    _ tqs = p.1;
    _ ts = p.2;
    _ ts2 = substs(inst,ts);
    _ tqts2 = List::zip(tqs,ts2);
    return ^typ.TupleType(tqts2);
  case Evar*(_,r,_):
    if (r != null) return(substitute(inst,r.v));
    else return t;
  case VoidType: return t;
  case XenumType(_): return t;
  case IntType(_): return t;
  case FloatType(_): return t;
  case DoubleType(_): return t;
  case BoolType(_): return t;
  case UnionType: return t;
  }
}
static <typ>list substs(<*(var,typ)>list inst, <typ>list ts) {
  return List::map_c(substitute,inst,ts);
}

exp default_initializer(tenv te, typ t, seg loc) {
  exp e = ^exp(null,^raw_exp.Const(^cnst.Null),null,loc);

  switch (compress(t)) {
  case PointerType(_):
    ;
  case IntType*(sign,sz,bx):
    if (bx == ^boxed.Boxed)
      terr(loc,
           sprintf("declaration of %s without initializer",
                   typ2string(t)));
    else if (sz == ^size_of.B1)
      // FIX: Char should have a sign
      e.raw_exp = ^raw_exp.Const(^cnst.Char('\000'));
    else {
      e.raw_exp = ^raw_exp.Const(^cnst.Int(^(sign,0)));
      if (sz != ^size_of.B4)
        e = ^exp(null,^raw_exp.Cast(^(t,e)),null,loc);
    }
  case BoolType(bx):
    if (bx == ^boxed.Boxed)
      terr(loc,
           sprintf("declaration of %s without initializer",
                   typ2string(t)));
    else e.raw_exp = ^raw_exp.Const(^cnst.Bool(false));
  case FloatType(bx):
    if (bx == ^boxed.Boxed)
      terr(loc,
           sprintf("declaration of %s without initializer",
                   typ2string(t)));
    else e.raw_exp = ^raw_exp.Const(^cnst.Float("0.0"));
  case DoubleType(bx):
    e.raw_exp =
      ^raw_exp.Cast(^(t,^exp(null, ^raw_exp.Const(^cnst.Float("0.0")),
                             null, loc)));

/*
  case ArrayType*(t,eopt):
    if (eopt == null)
      e.raw_exp = ^raw_exp.ConstArray(^(null,^Opt(t)));
    else {
      e.raw_exp =
	^raw_exp.FnCall(^(^exp(null,^raw_exp.Var("new_array"),null,loc),null,
	^list(eopt.v,^list(default_initializer(te,t,loc),null))));
    }

  case StringType:  e.raw_exp = ^raw_exp.Const(^cnst.String(""));
  case CharType:    e.raw_exp = ^raw_exp.Const(^cnst.Char('\000'));
  case TupleType(ts):
    e.raw_exp = ^raw_exp.NewTuple(List::map_c(def_init,^(te,loc),ts));
  case NamedType(p):
    _ n  = p.1;
    _ ts = p.2;
    // check for an opened type name
    if (!(Dict::member(te.structs,n)
	  || Dict::member(te.unions,n)
	  || Dict::member(te.abstracts,n))) {
      try {
	n = Dict::lookup(te.open_typs,n);
	p.1 = n;
      } catch {
      case Dict::Absent: terr2(loc,"unbound type name ",n);
      }
    }
    // if it's possibly null, we'e done otherwise...
    if (possibly_null(te,n)) return e;
    _ sdopt = Dict::lookup_opt(te.structs,n);
    _ udopt;
    if (sdopt != null) {
      // n is a struct -- return a struct of the default expressions for
      // each of the field types.
      _ sd = sdopt.v.1;
      _ inst = List::zip(sd.tvs,ts);
      _ es =
	List::map_c(fun *(<field_name>Opt,exp)
		     f(*(*(tenv,seg),<*(var,typ)>list) env,
		       *(field_name,capability,typ)               field){
		       return ^(null,def_init(env.1,subst(env.2,field.3)));
		    },
                   ^(^(te,loc),inst),
		   sd.fields);
      e.raw_exp = ^raw_exp.NewStruct(^(n,^Opt(ts),es));
    } else if ((udopt = Dict::lookup_opt(te.unions,n)) != null) {
      // n is a union -- return the first field (and an expression of the
      // argument type if any.)
      _ ud = udopt.v.1;
      if (ud.fields == null) {
	terr(loc,"Union has no fields!");
      } else {
	// get first field
	_ field = ud.fields.hd.1;
	// get its type
	typ t = ud.fields.hd.2;
	// if it's void then the field doesn't carry a value
	if (t == ^typ.VoidType)
	  e.raw_exp = ^raw_exp.NewUnion(^(n,^Opt(ts),field,null));
	else {
	  // otherwise construct a default value for that type
	  _ inst = List::zip(ud.tvs,ts);
	  _ e2 = ^Opt(default_initializer(te,subst(inst,t),loc));
	  e.raw_exp = ^raw_exp.NewUnion(^(n,^Opt(ts),field,e2));
	}
      }
    } else
      terr(loc,"Abstract types require initializers.");
  case FnType(_): terr(loc,"function pointer declarations require initializer");
  case ExnType:   terr(loc,"exception declarations require initializer");
*/

  default:
    terr(loc,
         sprintf("declaration of type %s requires initializer",
                 typ2string(t)));
  }
  return e;
}

*(var,typ) make_inst_var(var v) {
  return ^(v, new_evar(^kind.BoxKind));
}

/* Check that the type is valid assuming that the free type variables
   are drawn from the given list.  As a side-effect, expand any
   typedefs, and change relative type names to absolute type names. */
void check_valid_type(seg loc, tenv te, <tvar>list bound_vars, typ t) {
  switch (compress(t)) {
  case VoidType: ; // skip
  case Evar*(k,topt,i): ; // skip
  case VarType(tv):
    if (!List::mem(strcmp,bound_vars,tv)) 
      terr(loc,sprintf("unbound type variable %s",tv));
  case EnumType*(tdnopt,targs):
    if (tdnopt == null)
      terr(loc,"missing enum name");
    else {
      _ tdn = tdnopt.v;
      try {
	_ ed = lookup_enumdecl(te,loc,tdn);
        // Make relative name absolute
        if (ed.name != null) // sanity check
          tdn.1 = ed.name.v.1;
	int lvs = List::length(ed.tvs);
	int largs = List::length(targs);
	if (lvs != largs)
	  terr(loc,sprintf("enum %s expects %d type arguments, not %d",
			   qvar2string(tdn),lvs,largs));
	// check that each of the type arguments is well-formed and a box type
	for (; targs != null; targs = targs.tl) {
	  typ t = targs.hd;
	  check_valid_type(loc,te,bound_vars,t);
	  if (typ_kind(t) != box_k) 
	    terr(loc,sprintf("type %s is not a boxed type",typ2string(t)));
	}
      } catch {
      case Dict::Absent: 
	terr(loc,sprintf("unbound type enum %s",qvar2string(tdn)));
      }
    }
  case XenumType(tdn):
    try {
      _ xed = lookup_xenumdecl(te,loc,tdn);
      // Make relative name absolute
      tdn.1 = xed.name.1;
    } catch {
    case Dict::Absent:
      terr(loc,sprintf("unbound xenum %s",qvar2string(tdn)));
    }
  case PointerType*(t,nullable,tq):
    // FIX: check that tqual is valid?
    check_valid_type(loc,te,bound_vars,t);
  case IntType(_): ; // skip
  case BoolType(_): ; // skip
  case FloatType(_): ; // skip
  case DoubleType(_): ; // skip
  case ArrayType*(t,tq,ak):
    // FIX: check that tqual is valid?
    check_valid_type(loc,te,bound_vars,t);
    switch (ak) {
    case UntaggedArray: ; // skip
    case TaggedArray  : ; // skip
    case FixedArray(e):
      // FIX: should memoize the size so that we don't have to worry about
      // evaluating it during unification.
      eval_const_uint_exp(e); // check that e is of constant size
    }
  case FnType*(btvs,tr,args,vararg):
    check_unique_tvars(loc,btvs);
    <tvar>list new_bound_vars = List::append(btvs,bound_vars);
    check_valid_type(loc,te,new_bound_vars,tr);
    for (; args != null; args = args.tl) {
      // FIX: should check that variables are unique that tquals are
      // okay.
      check_valid_type(loc,te,new_bound_vars,args.hd.3);
    }
  case TupleType(tq_ts):
    // FIX: check the tquals
    for (; tq_ts != null; tq_ts = tq_ts.tl) {
      check_valid_type(loc,te,bound_vars,tq_ts.hd.2);
    }
  case StructType*(tdnopt,targs):
    if (tdnopt == null) 
      terr(loc,"missing struct name");
    else {
      _ tdn = tdnopt.v;
      try {
	structdecl sd = lookup_structdecl(te,loc,tdn);
        // Make relative name absolute
        if (sd.name != null) // sanity check
          tdn.1 = sd.name.v.1;
	int lvs = List::length(sd.tvs);
	int largs = List::length(targs);
	if (lvs != largs) 
	  terr(loc,
               sprintf("struct %s expects %d type arguments but was given %d",
                       qvar2string(tdn),lvs,largs));
	// check that each of the type arguments is well-formed and a box type
	for (; targs != null; targs = targs.tl) {
	  typ t = targs.hd;
	  check_valid_type(loc,te,bound_vars,t);
	  if (typ_kind(t) != box_k)
	    terr(loc,sprintf("type %s is not a boxed type",typ2string(t)));
	}
      } catch {
      case Dict::Absent:
	terr(loc,sprintf("unbound type struct %s",qvar2string(tdn)));
      }
    }
  case TypedefType(triple):
    _ tdn = triple.1;
    _ targs = triple.2;
    _ topt = triple.3; // NB: since we called compress topt == null
    try {
      typedefdecl td = lookup_typedefdecl(te,loc,tdn);
      tdn.1 = td.name.1; // Make relative name absolute
      for (<typ>list ts = targs; ts != null; ts = ts.tl) {
	check_valid_type(loc,te,bound_vars,ts.hd);
	if (typ_kind(ts.hd) != box_k)
	  terr(loc,sprintf("type %s is not a boxed type",typ2string(ts.hd)));
      }
      <*(var,typ)>list inst = List::zip(td.tvs,targs);
      typ new_t = substitute(inst,td.defn);
      // TJ: I think we don't need this.  Presumably the typedefdecl
      // has been validated before entry into the environment; if
      // that's so and the type arguments are valid and boxed, the
      // result of the substitution should be valid as well.  Note, if
      // we DO need this we have to change something, because the type
      // names in the typedefdecl are absolute, but check_valid_type
      // assumes they are relative and changes them to absolute.
      //
      // check_valid_type(loc,te,bound_vars,new_t);
      triple.3 = ^Opt(new_t);
    } catch {
    case Dict::Absent:
      terr(loc,sprintf("unbound typedef name %s",qvar2string(tdn)));
    case List::List_mismatch:
      terr(loc,sprintf("typedef %s expects a different number of arguments",
		       qvar2string(tdn)));
    }
  case UnionType: terr(loc,"union type unsupported");
  } // end switch
}

<var>set repeated_vars(<var>list vs) {
  <var>set seen = Set::empty(strcmp);
  <var>set repeated = Set::empty(strcmp);
  for (; vs != null; vs = vs.tl) {
    if (Set::member(seen,vs.hd))
      repeated = Set::insert(repeated,vs.hd);      
    else seen = Set::insert(seen,vs.hd);
  }
  return repeated;
}

void check_unique_tvars(seg loc, <tvar>list tvs) {
  try {
    tvar x = Set::choose(repeated_vars(tvs));
    terr(loc,sprintf("duplicate type variable %s",x));
  } catch {
  case Set::Absent: ; // skip
  }
}

/* remove the field name f from a list of fields -- return the field
   and the mutated list. */
exception MissingField;
*(*(field_name,tqual,typ),<*(field_name,tqual,typ)>list)
remove_field(field_name f, <*(field_name,tqual,typ)>list fs) {
  if (fs == null) raise MissingField();
  if (strcmp(f,fs.hd.1) == 0)
    return (^(fs.hd,fs.tl));
  _ orig = fs;
  _ prev = fs;
  fs = fs.tl;
  while (fs != null) {
    if (strcmp(f,fs.hd.1) == 0) {
      prev.tl = fs.tl;
      return(^(fs.hd,orig));
    } else {
      prev = fs;
      fs = fs.tl;
    }
  }
  raise MissingField();
}
