/* Type checking for expressions */

/* TODO:
   codegen and fill
   compound literals
   generalized array and struct designators
   unresolvedmem
 */

#include "absyn.h"
#include "gcdfec.h"
#include "synpp.h"
#include "tcenv.h"
#include "tcutil.h"
#include "evexp.h"
#include "tcstmt.h"

prefix Tcexp;
open Tcexp;

open Core;
open List;
open Gcdfec;
open Absyn;
open Synpp;
open Tcenv;
open Tcutil;
open Evexp;
open Tcstmt;

// shared error-generating function
static synth expr_err(tenv te,seg loc,string msg) {
  terr(loc,msg);
  return wild_synth(te);
}

// Type check an expression e.  The value topt is an optional type
// that we expect e to have.  This is useful for propagating type
// information down (i.e., to resolve certain ambiguous expression
// forms) but isn't otherwise used -- one still needs to check that
// e has the expected type.  If e="e2<>" and e2 has a poly-type, 
// we do not instantiate the type quantifiers.  Otherwise if e has a
// poly-type, we instantiate the quantifiers. 
synth tcExp(tenv te, <typ>Opt topt, exp e) {
  te = clear_fallthru(te);
  synth esyn;
  switch (e.raw_exp) {
  case NoInstantiate(e2):
    // the user has asked not to implicitly instantiate any quantifiers
    esyn = tcExpNoInst(te,topt,e2);
    e.topt = e2.topt;
  default:
    // implicitly instantiate the expression if it has a polymorphic type
    esyn = tcExpNoInst(te,topt,e); // first, typecheck without instantiating
    // TESTING FUNCTION STUFF
    esyn = synth_set_typ(esyn,pointer_expand(compress(synth_typ(esyn))));
    e.topt = ^Opt(synth_typ(esyn));
    switch (compress(synth_typ(esyn))) {
    case PointerType*(t,x,tq):
      switch (compress(t)) {
      case FnType*(tvs,rtyp,args,varargs):
        if (tvs != null) {   // then, instantiate if necessary
          <*(var,typ)>list instantiation = List::map(make_inst_var,tvs);
          <typ>list ts = List::map(snd@<var,typ>,instantiation);
          typ ftyp = substitute(instantiation,
                                ^typ.FnType(^(null,rtyp,args,varargs)));
          typ new_typ = ^typ.PointerType(^(ftyp,x,tq));
          exp inner = ^exp{topt=e.topt,
                           raw_exp=e.raw_exp,
                           assigned_to=e.assigned_to,
                           loc=e.loc};
          e.raw_exp = ^raw_exp.Instantiate(^(inner,^Opt(ts)));
          e.topt = ^Opt(new_typ);
          esyn = synth_set_typ(esyn,new_typ);
        }
      default:
        ; // skip
      }
    default:
      ; // skip
    }
  }
  return esyn;
}

/* Type-check the expression -- don't do any implicit instantiation. */
static synth tcExpNoInst(tenv te, <typ>Opt topt, exp e) {
  seg loc = e.loc;
  synth esyn;

  switch (e.raw_exp) {
  case NoInstantiate(_)        :
    // This would handle two NoInstantiates in a row; but note that
    // for now the parser does not produce this ( x<><> won't parse ).
    return tcExp(te,null,e);
  case UnknownId(q)            :
    // resolve the identifier and then re-type-check the expression
    resolve_unknown_id(te,e,q);
    return tcExp(te,topt,e);
  case UnknownCall*(e1,es)     :
    // resolve e1 as a function or struct, enum, or xenum constructor and
    // then re-type-check the expression
    resolve_unknown_fn(te,e,e1,es);
    return tcExp(te,topt,e);
  case UnresolvedMem*(nopt,ds) :
    // resolve as an array or struct and then re-type-check the expression
    resolve_unresolved_mem(te,loc,topt,e,nopt,ds);
    return tcExp(te,topt,e);
  /* Dispatch the other cases */
  case Const(c)                : esyn = tcConst(te,loc,topt,c);
  case Var(q)                  : esyn = tcVar(te,loc,topt,q,e);
  case Primop(pr)              : esyn = tcPrimop(te,loc,topt,pr);
  case Increment(pr)           : esyn = tcIncrement(te,loc,topt,pr);
  case AssignOp*(e1,popt,e2)   : esyn = tcAssignOp(te,loc,topt,e,e1,popt,e2);
  case Conditional*(e1,e2,e3)  : esyn = tcConditional(te,loc,topt,e1,e2,e3);
  case SeqExp*(e1,e2)          : esyn = tcSeqExp(te,loc,topt,e1,e2);
  case FnCall*(e1,es)          : esyn = tcFnCall(te,loc,topt,e1,es);
  case Throw(e1)               : esyn = tcThrow(te,loc,topt,e1);
  case Instantiate(p)          : esyn = tcInstantiate(te,loc,topt,p);
  case Cast*(t,e1)             : esyn = tcCast(te,loc,topt,t,e1);
  case Address(e1)             : esyn = tcAddress(te,loc,topt,e1);
  case Sizeof(t)               : esyn = tcSizeof(te,loc,topt,t);
  case Deref(e1)               : esyn = tcDeref(te,loc,topt,e1);
  case StructMember*(e1,f)     : esyn = tcStructMember(te,loc,topt,e1,f);
  case StructArrow*(e1,f)      : esyn = tcStructArrow(te,loc,topt,e1,f);
  case Subscript*(e1,e2)       : esyn = tcSubscript(te,loc,topt,e1,e2);
  case Tuple(es)               : esyn = tcTuple(te,loc,topt,es);
  case CompoundLit*(t,des)     : esyn = tcCompoundLit(te,loc,topt,t,des);
  case Array(des)              : esyn = tcArray(te,loc,topt,des);
  case Comprehension*(v,e1,e2) : esyn = tcComprehension(te,loc,topt,v,e1,e2);
  case Struct(arg)             : esyn = tcStruct(te,loc,topt,arg);
  case Enum(arg)               : esyn = tcEnum(te,loc,topt,arg);
  case Xenum(arg)              : esyn = tcXenum(te,loc,topt,arg);
  case StmtExp(s)              : esyn = tcStmtExp(te,loc,topt,s);
  case Codegen(fd)             : esyn = tcCodegen(te,loc,topt,fd);
  case Fill(e1)                : esyn = tcFill(te,loc,topt,e1);
  }
  e.topt = ^Opt(synth_typ(esyn));
  return esyn;
}

/* The qualified identifier q could be a variable, an enum
   constructor, or an xenum constructor.  We resolve q and overwrite
   the expression e with the appropriate raw_exp. */
static void resolve_unknown_id(tenv te, exp e, qvar q) {
  switch (lookup_ordinary(te,e.loc,q)) {
  case LocalRes(_):
    e.raw_exp = ^raw_exp.Var(q);
  case GlobalRes(_):
    e.raw_exp = ^raw_exp.Var(q);
  case EnumRes*(ed,ef):
    e.raw_exp = ^raw_exp.Enum(^(ef.name,null,null,null,ed,ef));
  case XenumRes*(xed,ef):
    e.raw_exp = ^raw_exp.Xenum(^(ef.name,null,null,xed,ef));
  case UnknownRes:
    // No error is reported here -- that is handled by tcVar
    e.raw_exp = ^raw_exp.Var(q);
  case StructRes(_):
    terr(e.loc,sprintf("bad occurrence of struct name %s",qvar2string(q)));
    e.raw_exp = ^raw_exp.Var(q);
  }
}

/* Resolve whether this is a function call or enum, xenum, or struct
   constructor -- let normal type-checking do the rest of the work. */
static void resolve_unknown_fn(tenv te, exp e, exp e1, <exp>list es) {
  switch (e1.raw_exp) {
  case UnknownId(q):
    switch (lookup_ordinary(te,e1.loc,q)) {
    case LocalRes(_):
      e.raw_exp = ^raw_exp.FnCall(^(e1,es));
    case GlobalRes(_):
      e.raw_exp = ^raw_exp.FnCall(^(e1,es));
    case EnumRes*(ed,ef):
      if (ed.name != null) {
        e.raw_exp = ^raw_exp.Enum(^(ef.name,null,null,es,ed,ef));
      } else {
        terr(e.loc,"missing enum name");
        e.raw_exp = ^raw_exp.Enum(^(q,null,null,es,ed,ef));
      }
    case XenumRes*(xed,ef):
      e.raw_exp = ^raw_exp.Xenum(^(ef.name,null,es,xed,ef));
    case StructRes(sd):
      _ des = List::map(make_struct_arg,es);
      if (sd.name != null)
        e.raw_exp = ^raw_exp.Struct(^(sd.name.v,null,des,^Opt(sd)));
      else {
        terr(e.loc,"missing struct name");
        e.raw_exp = ^raw_exp.Struct(^(q,null,des,^Opt(sd)));
      }
    case UnknownRes:
      e.raw_exp = ^raw_exp.FnCall(^(e1,es));
    }
  default: e.raw_exp = ^raw_exp.FnCall(^(e1,es));
  }
}

///////////////// UnresolvedMem //////////////////////////
static void
resolve_unresolved_mem(tenv te, seg loc, <typ>Opt topt, exp e,
		       <typedef_name>Opt nopt,
		       <*(<designator>list,exp)>list des) {
  if (topt == null) {
    terr(loc, "cannot resolve type of initializer");
    // guess it's an array
    e.raw_exp = ^raw_exp.Array(des);
    return; 
  }
  typ t = topt.v;
  switch (compress(t)) {
  case ArrayType*(at,aq,ak):
    e.raw_exp = ^raw_exp.Array(des);
  case StructType*(tdopt,ts):
    e.raw_exp = ^raw_exp.Struct(^(tdopt.v,null,des,null));
  default:
    terr(loc, sprintf("invalid initializer for type %s -- expecting array or struct type",typ2string(t)));
  }
}

static *(<designator>list,exp) make_struct_arg(exp e) {
  return ^(null,e);
}

static void resolve_any_unknown_id(tenv te, exp e) {
  switch (e.raw_exp) {
  case UnknownId(q): resolve_unknown_id(te,e,q);
  default:
    ; // skip
  }
}


// Type check a list of expressions returning a sequentialized synth -- the
// type in the resulting synth is bogus, but the other information is valid.
static synth tcExpList(tenv te, <exp>list es) {
  synth s = skip_synth(te);
  while(es != null) {
    s = seq_synth(s, tcExp(te,null,es.hd));
    te = layer_synth(te,s);
    es = es.tl;
  }
  return s;
}

// constants
static synth tcConst(tenv te, seg loc, <typ>Opt topt, cnst c) {
  typ t;
  switch (c) {
  case Char(_)  : t = uchar_t;
  case Int*(s,i):
    // FIX: take i into account
    t = (s == ^sign.Unsigned) ? uint_t : sint_t;
  case Short(_) : t = ushort_t; // TODO: IS THIS POSSIBLE?
  // case Long(_): t = slong_t;
  case Bool(_)  : t = bool_t;
  case Float(_) : t = float_t;
  case String(s):
    int len = size(s)+1; // len to include a trailing 0 character
    raw_exp r = ^raw_exp.Const(^cnst.Int(^(^sign.Unsigned,len)));
    exp e = ^exp {topt = ^Opt(uint_t), raw_exp = r, assigned_to = null,
		  loc = loc};
    t = ^typ.ArrayType(^(uchar_t,empty_tqual(),^array_kind.FixedArray(e)));
  case Null:
    // FIX: take advantage of topt
    t = ^typ.PointerType(^(wildtyp(),^conref(^constraint.Eq(true)),
			   empty_tqual()));
  }
  return standard_synth(te,t);
}

/* variables */
static synth tcVar(tenv te, seg loc, <typ>Opt topt, qvar q, exp exp) {
  switch (lookup_ordinary(te,loc,q)) {
  case UnknownRes:
    return expr_err(te,loc,sprintf("unbound identifier %s",qvar2string(q)));
  case LocalRes(vi):
    // Invariant: q.1==null
    if (Set::member(get_unassigned(te),q.2))
      terr(loc,sprintf("identifier %s might not be initialized",q.2));
    vi.is_used = true;
    return standard_synth(te,vi.t);
  case GlobalRes*(fullname,vi):
    q.1 = fullname.1;
    vi.is_used = true;
    return standard_synth(te,vi.t);
  case StructRes(_):
    return impos("StructRes in lhs_const");
  case EnumRes(_):
    return impos("EnumRes in lhs_const");
  case XenumRes(_):
    return impos("XenumRes in lhs_const");
  }
}

static void check_format_args(tenv te, exp fmt, <exp>list args) {
  string fmt_str;
  <typ>list desc_types = null;
  int i = 0;

  // get out the literal format string
  switch (fmt.raw_exp) {
  case Const(c):
    switch (c) {
    case String(s): fmt_str = s;
    default: 
      terr(fmt.loc, "expecting a literal format string");
      return;
    }
  default: 
    terr(fmt.loc, "expecting a literal format string");
    return;
  }
  int len = size(fmt_str);
  // calculate the types
  while (i < len) {
    if (fmt_str[i] == '%') {
      ++i;
      if (i < len) {
	// FIX: should deal with real formatting
	switch (fmt_str[i]) {
	case 'c': desc_types = ^list(uchar_t, desc_types);
	case 'd': desc_types = ^list(sint_t, desc_types);
	case 'u': desc_types = ^list(uint_t, desc_types);
	case 'x': desc_types = ^list(uint_t, desc_types);
	case 'f': desc_types = ^list(float_t, desc_types);
	case 's': desc_types = ^list(string_t(), desc_types);
	case 'g': desc_types = ^list(double_t, desc_types);
	case '%': ; // skip
	default: 
	  terr(fmt.loc, sprintf("bad format character %c",fmt_str[i]));
	}
	++i;
      }
    } else 
      ++i;
  }
  desc_types = List::imp_rev(desc_types);
  // now check that each desc_type matches the expression types
  for (; desc_types != null && args != null; desc_types = desc_types.tl, 
	 args = args.tl) {
    typ t = desc_types.hd;
    exp e = args.hd;
    if (!coerce_arg(te,e,t))
      terr(e.loc,sprintf("descriptor has type %s but argument has type %s",
		       typ2string(t), typ2string(e.topt.v)));
  }
  if (desc_types != null)
    terr(fmt.loc,sprintf("descriptor expects another value of type %s",
		     typ2string(desc_types.hd)));
  else if (args != null)
    terr(args.hd.loc,"too many arguments");
}

/* Primops.
   Unlike Java, the only binops on bools are == and !=.  (The parser
   expands && and || into Conditionals and there's no ^ or | or & on
   booleans.) For == and != on booleans we do nothing special yet,
   unlike Java so for example, true == true will behave differently. */
static synth tcPrimop(tenv te, seg loc, <typ>Opt topt, *(primop, exps) pair) {
  // FIX: sizeof(f) where f is a function (or expression of function type)
  // should not be allowed.  So for sizeof(e), we should not call tcExp on e,
  // because that will do pointer generation (convert a function to a pointer
  // to a function).  Instead we should call tcexpNoInst.
  _ p  = pair.1;
  _ es = pair.2;
  _ es_result = tcExpList(te,es);
  _ typ;
  switch (p) {
  case Printf:
    if (es == null)
      return expr_err(te,loc,"missing format string in printf");
    check_format_args(te, es.hd, es.tl);
    typ = ^typ.VoidType;
  case Fprintf:
    if (es == null || es.tl == null)
      return
        expr_err(te,loc,"missing file descriptor or format string in fprintf");
    if (!unify(es.hd.topt.v, file_t()))
      terr(es.hd.loc,sprintf("expecting FILE @ but found %s",
			     typ2string(es.hd.topt.v)));
    check_format_args(te, es.tl.hd, es.tl.tl);
    typ = ^typ.VoidType;
  case Xprintf:
    if (es == null)
      return expr_err(te,loc,"missing format string in xprintf");
    check_format_args(te, es.hd, es.tl);
    typ = string_t();
  default:
    switch (List::length(es)) {
    case 0:
      return expr_err(te,loc,"primitive operator applied to no arguments");
    case 1:
      typ = tcUnPrimop(te,loc,topt,p,es.hd);
    case 2:
      typ = tcBinPrimop(te,loc,topt,p,es.hd,es.tl.hd);
    default:
      return expr_err(te,loc,
		      sprintf("primitive operator %s has too many arguments",
			      prim2string(p)));
    }
  }
  return synth_set_typ(es_result,typ);
}

static synth tcIncrement(tenv te, seg loc, <typ>Opt topt, 
			 *(exp, incrementor) pair) {
  _ e = pair.1;
  _ i = pair.2;
  resolve_any_unknown_id(te,e);
  _ esyn = tcExp(te, null, e);
  // FIX: this is probably not right -- for instance, it would allow
  // an enum variable to be "incremented"
  if (!arithmetic_promote(te,e)) {
    terr(e.loc,sprintf("expecting arithmetic type but found %s",
		       typ2string(e.topt.v)));
  }
  return synth_set_typ(esyn, e.topt.v);
}

/* e1 ? e2 : e3
   NB: some care is taken here to more accurately track initialization,
   hence the complexity. */
static synth tcConditional(tenv te, seg loc, <typ>Opt topt, 
			   exp e1, exp e2, exp e3) {
  synth esyn1,esyn2,esyn3;
  typ t;

  esyn1 = tcExp(te,^Opt(bool_t),e1);
  if (!coerce_bool_t(te,e1))
    terr(e1.loc,sprintf("conditional argument has type %s instead of bool",
                        typ2string(e1.topt.v)));
  _ te_pr = bool_layer_synth(te, esyn1);
  esyn2 = tcExp(te_pr.1, topt, e2);
  esyn3 = tcExp(te_pr.2, topt, e3);
  typ t = wildtyp();
  if (!coerce_list(te,t,^list(e2,^list(e3,null)))) {
    expr_err(te,loc,
	    sprintf("clauses of conditional do not match type: %s != %s",
		    typ2string(e2.topt.v),typ2string(e3.topt.v)));
  }
  return join_synth(seq_synth(esyn1,esyn2), seq_synth(esyn1,esyn3));
}

/* Assignments with optional operations, e.g., x = 3, x += 5
   Note that as in tcPrimop, we violate Java by not considering
   various boolean operators to have meaning.  Must check lhs before
   rhs, but if lhs is a Var, and there's no Op, then the Var is
   allowed to be undefined. */
static
synth tcAssignOp(tenv te,seg loc,<typ>Opt topt,exp e0,exp e1,<primop>Opt po,
		 exp e2) {
  _ te_lhs;
  resolve_any_unknown_id(te,e1);
  resolve_any_unknown_id(te,e2);
  switch (e1.raw_exp) {
  case Var(q):
    if (po == null && q.1 == null)
      // assignment without an operator to a local variable
      te_lhs = set_unassigned(te,Set::delete(get_unassigned(te),q.2));
    else
      te_lhs = te;
  default: te_lhs = te;
  }
  _ esyn_lhs = tcExp(te_lhs, null, e1);
  _ t1       = synth_typ(esyn_lhs);
  // Check to see if e1 is an lvalue after typechecking, so that
  // UnknownIds can be resolved.
  if (!is_lvalue(e1))
    return expr_err(te,loc,"assignment to non-lvalue");
  /*
  check_valid_lhs(te,e1);
  */
  _ te_rhs;
  switch (e1.raw_exp) {
  case Var(_): te_rhs = te;
  default:     te_rhs = layer_synth(te,esyn_lhs);
  }
  _ esyn_rhs    = tcExp(te_rhs, null, e2);
  _ t2          = synth_typ(esyn_rhs);
  _ synth_after = esyn_rhs;

  switch (e1.raw_exp) {
  case Var(v):
    synth_after = initialize_var_synth(seq_synth(esyn_lhs,esyn_rhs),v.2);
  default:
    synth_after = seq_synth(esyn_lhs,esyn_rhs);
  }

  if (po == null) {
    if (!coerce_assign(te,e2,t1)) {
      return expr_err(te,loc,sprintf("type mismatch: %s != %s",
				    typ2string(t1), typ2string(t2)));
    }
  } else {
    _ p        = po.v;
    _ t_result = tcBinPrimop(te,loc,null,p,e1,e2);
    if (!(unify(t_result,t1) || coerceable(t_result))) {
      return expr_err(te,loc,"Cannot use this operator in front of an assignment");
    }
  }
  return synth_after;
}

/* e1,e2 */
static synth tcSeqExp(tenv te, seg loc, <typ>Opt topt, exp e1, exp e2) {
  _ r = tcExpList(te,^list(e1,^list(e2,null)));
  return synth_set_typ(r,e2.topt.v);
}

/* e(es) */
static synth tcFnCall(tenv te, seg loc, <typ>Opt topt, exp e, <exp>list es) {
  _ list_result = tcExpList(te,^list(e,es));
  typ t = compress(e.topt.v);
  // NB: we should really unify t with an unconstrained FnType with the
  // right arity but there may be coercions involved with the arguments
  // and the function might actually be a vararg.
  switch (t) {
  case PointerType*(t,x,tq):
    // FIX: insert null check if necessary
    switch (compress(t)) {
    case FnType*(tvars,res_t,args_info,is_vararg): //TODO: handle tvars
      if (is_vararg)
        terr(loc,"vararg functions (...) not supported yet");
      // for each argument -- check that it has the appropriate type, coercing
      // as necessary
      while ((es != null) && (args_info != null)) {
        exp e = es.hd;
        typ t = args_info.hd.3;
        typ t2 = e.topt.v;
        if (!coerce_arg(te,e,t))
          terr(loc,
               sprintf("actual argument has type %s but formal has type %s",
                       typ2string(t2),typ2string(t)));
        es = es.tl;
        args_info = args_info.tl;
      }
      if (es != null) {
        return expr_err(te,loc,"too many arguments for function");
      }
      else if (args_info != null) {
        return expr_err(te,loc,"too few arguments for function");
      }
      return synth_set_typ(list_result,res_t);
    default:
      return expr_err(te,loc,"expected pointer to function");
    }
  default:
    return expr_err(te,loc,"expected pointer to function");
  }
}

/* throw e */
static synth tcThrow(tenv te, seg loc, <typ>Opt topt, exp e) {
  typ t = synth_typ(tcExp(te,^Opt(exn_t),e));
  if (!unify(t,exn_t)) {
    expr_err(te, loc,sprintf("expected xenum exn but found %s",typ2string(t)));
  }
  return empty_synth(te);
}

/* (implicit) instantiation */
// TODO: this is really untested, because the parser does not
// insert Instantiate expressions, only the typechecker does,
// and the output of the typechecker isn't passed through itself...
static synth tcInstantiate(tenv te, seg loc, <typ>Opt topt, 
			   *(exp,<<typ>list>Opt) p) {
  exp e = p.1;
  <<typ>list>Opt topts = p.2;
  synth esyn = tcExp(te,null,e);
  typ t0 = compress(synth_typ(esyn));
  switch (t0) {
  case PointerType*(t,_,_):
    switch (t) {
    case FnType*(tvars,rtyp,args,varargs):
      <*(var,typ)>list instantiation;
      if (topts == null) {
        instantiation = List::map(make_inst_var,tvars);
        p.2 = ^Opt(snd(List::split(instantiation)));
      } else {
        try
          instantiation = List::zip(tvars,topts.v);
        catch {
        case List::List_mismatch:
          return expr_err(te,loc,"type instantiation mismatch");
        }
      }
      typ new_typ = substitute(instantiation,
                               ^typ.FnType(^(null,rtyp,args,varargs)));
      return synth_set_typ(esyn,new_typ);
    default:
      return expr_err(te,loc,sprintf("expecting polymorphic type but found %s",
                                     typ2string(t0)));
    }
  default:
    return expr_err(te,loc,sprintf("expecting polymorphic type but found %s",
                                   typ2string(t0)));
  }
}

/* (t)e */
static synth tcCast(tenv te, seg loc, <typ>Opt topt, typ t, exp e) {
  check_valid_type(loc,te,lookup_type_vars(te),t);
  synth esyn = tcExp(te,null,e);
  typ t2 = synth_typ(esyn);
  if (!castable(te,loc,t2,t)) {
    return expr_err(te,loc,sprintf("cannot cast %s to %s",typ2string(t2),
				  typ2string(t)));
  }
  return synth_set_typ(esyn,t);
}

/* &e */
static synth tcAddress(tenv te, seg loc, <typ>Opt topt, exp e) {
  //  if (!is_lvalue(e))
  //    return expr_err(te,loc,"unary & applied to non-lvalue");
  // TESTING FUNCTION STUFF
  // Use tcExpNoInst here because if f is a function then
  // then &f is supposed to be a pointer to a function, not
  // a pointer to a pointer to a function
  // FIX: still busted...
  synth esyn = tcExpNoInst(te,topt,e);
  tqual tq = ^tqual{q_const = lhs_const(te,e),
		    q_volatile=false, q_restrict=false};
  typ t = ^typ.PointerType(^(synth_typ(esyn),
			     ^conref(^constraint.Eq(false)),tq));
  return synth_set_typ(esyn,t);
}

// if e is a valid lhs, then return true if that lhs must be const,
// otherwise, return false.
static bool lhs_const(tenv te, exp e) {
  // in some situations, the pointer must actually be const
  switch (e.raw_exp) {
  case Var(q):
    switch (lookup_ordinary(te,e.loc,q)) {
    case LocalRes(vi): return vi.tq.q_const;
    case GlobalRes*(_,vi): return vi.tq.q_const;
    case UnknownRes:
      terr(e.loc,"UnknownVar in lhs_const");
      return false;
    case StructRes(_):
      return impos("StructRes in lhs_const");
    case EnumRes(_):
      return impos("EnumRes in lhs_const");
    case XenumRes(_):
      return impos("XenumRes in lhs_const");
    }
  case Cast*(_,e): return lhs_const(te,e);
  case StructMember*(e,f):
    typ t = compress(e.topt.v);
    switch (t) {
    case StructType*(nopt,ts):
      _ sd = lookup_structdecl(te,e.loc,nopt.v);
      _ fields = sd.fields == null ? null : sd.fields.v;
      while (fields != null) {
	if (strcmp(fields.hd.1,f) == 0)
	  return fields.hd.2.q_const;
	fields = fields.tl;
      }
      terr(e.loc,sprintf("bad field %s in struct %s",f,qvar2string(nopt.v)));
      return false;
    default:
      terr(e.loc,"expression is not a struct");
      return false;
    }
  case Subscript*(e1,e2):
    typ t = compress(e.topt.v);
    switch (t) {
    case ArrayType*(_,tqual,_): return tqual.q_const;
    case TupleType(ts):
      unsigned int i = eval_const_uint_exp(e2);
      while (i != 0) {
	ts = ts.tl;
	--i;
      }
      return ts.hd.1.q_const;
    default:
      terr(e.loc,sprintf("expression is not an array or tuple, it has type %s",
                         typ2string(t)));
      return false;
    }
  default: return false;
  }
}

static void ok_sizeof(tenv te, seg loc, typ t) {
  switch (compress(t)) {
  case VoidType: terr(loc,"cannot apply sizeof to void type");
  case Evar(_): impos("sizeof on evar!");
  case VarType(_): return;
  case EnumType(_): return;
  case XenumType(_): return;
  case PointerType(_): return;
  case IntType(_): return;
  case BoolType(_): return;
  case FloatType(_): return;
  case DoubleType(_): return;
  case ArrayType*(t,tq,ak):
    switch (ak) {
    case UntaggedArray: 
      terr(loc,sprintf("cannot apply sizeof to untagged array type %s",
		       typ2string(t)));
    case TaggedArray: return;
    case FixedArray(_): ok_sizeof(te,loc,t); return;
    }
  case FnType(_):
    terr(loc,"sizeof applied to function type");
    return;
  case TupleType(tqts):
    for (; tqts != null; tqts = tqts.tl)
      ok_sizeof(te,loc,tqts.hd.2);
    return;
  case StructType*(tdopt,ts):
    if (tdopt != null) {
      _ td = tdopt.v;
      _ sd = lookup_structdecl(te,loc,td);
      _ inst = List::map(make_inst_var,sd.tvs);
      if (sd.fields == null) {
	terr(loc,sprintf("struct %s is abstract -- cannot apply sizeof",
			 qvar2string(td)));
	return;
      }
      for (_ fs = sd.fields.v; fs != null; fs = fs.tl) {
	ok_sizeof(te,loc,substitute(inst,fs.hd.3));
      }
    }
    return;
  case UnionType: 
    impos("ok_sizeof: uniontype");
  case TypedefType(_):
    impos("ok_sizeof: typedeftype");
  }
}

/* sizeof t */
static synth tcSizeof(tenv te, seg loc, <typ>Opt topt, typ t) {
  check_valid_type(loc,te,lookup_type_vars(te),t);
  ok_sizeof(te,loc,t);
  return standard_synth(te,uint_t);
}

/* *e */
static synth tcDeref(tenv te, seg loc, <typ>Opt topt, exp e) {
  synth esyn = tcExp(te,null,e);
  typ t = compress(e.topt.v);
  switch (t) {
  case PointerType*(t2,_,_):
    return synth_set_typ(esyn,t2);
  default:
    return expr_err(te,loc,sprintf("expecting * or @ type but found %s",
				  typ2string(t)));
  }
}

/* e.f */
static synth tcStructMember(tenv te, seg loc, <typ>Opt topt, 
			    exp e, field_name f) {
  synth esyn = tcExp(te,null,e);
  typ t = compress(e.topt.v);
  switch (t) {
  case StructType*(nopt,ts):
    if (nopt == null)
      return expr_err(te,loc,"unresolved struct type (COMPILER ERROR)");
    _ n = nopt.v; // FIX: is this guaranteed non-null?
    _ sd = lookup_structdecl(te,loc,n);
    _ finfo_opt = lookup_struct_field(sd,f);
    if (finfo_opt == null) {
      return expr_err(te,loc,sprintf("struct %s has no %s field",
				    qvar2string(n),f));
    }
    _ inst = List::zip(sd.tvs,ts);
    _ typ = substitute(inst,finfo_opt.v.2);
    return synth_set_typ(esyn,typ);
  default:
    return expr_err(te,loc,sprintf("expecting struct, found %s",typ2string(t)));
  }
}

/* e->f */
static synth tcStructArrow(tenv te, seg loc, <typ>Opt topt, 
			   exp e, field_name f) {
  synth esyn = tcExp(te,null,e);
  typ t = compress(e.topt.v);
  switch (t) {
  case PointerType*(t2,_,_):
    switch (compress(t2)) {
    case StructType*(nopt,ts):
      _ n = nopt.v; // FIX: is this guaranteed non-null?
      _ sd = lookup_structdecl(te,loc,n);
      _ finfo_opt = lookup_struct_field(sd,f);
      if (finfo_opt == null) {
	return expr_err(te,loc,sprintf("struct %s has no %s field",
				       qvar2string(n),f));
      }
      _ inst = List::zip(sd.tvs,ts);
      _ typ = substitute(inst,finfo_opt.v.2);
      return synth_set_typ(esyn,typ);
    default:
      return expr_err(te,loc,sprintf("expecting struct pointer, found %s pointer",typ2string(t)));
    }
  default:
      return expr_err(te,loc,sprintf("expecting struct pointer, found %s",typ2string(t)));
  }
}

/* e1[e2] */
static synth tcSubscript(tenv te, seg loc, <typ>Opt topt, exp e1, exp e2) {
  _ list_result = tcExpList(te,^list(e1,^list(e2,null)));
  typ res_t;
  typ t1 = compress(e1.topt.v);
  typ t2 = compress(e2.topt.v);
  // NOTE: we use unsigned int here, unlike C, because we do not support
  // negative indexing on arrays.
  if (!coerce_uint_t(te,e2)) {
    return expr_err(te,e2.loc,sprintf("expecting unsigned int, found %s",
				     typ2string(t2)));
  }
  // the subscript could be on a tuple, a pointer to a tuple, or an array
  switch (t1) {
  case PointerType*(t,_,tq):
    // FIX: see whether pointer is nullable? Consider tq?
    switch (t) {
    case TupleType(ts):
      unsigned int i = eval_const_uint_exp(e2);
      try {
        res_t = List::nth(ts,i).2;
      } catch {
      case Nth:
        return expr_err(te,loc,
		       sprintf("index is %d but tuple has only %d fields",
			       i,List::length(ts)));
      }
    default:
      return expr_err(te,loc,
		     sprintf("subscript applied to %s (array or tuple required)", typ2string(t2)));
    }
  case TupleType(ts):
    unsigned int i = eval_const_uint_exp(e2);
    try {
      res_t = List::nth(ts,i).2;
    } catch {
    case Nth:
      return expr_err(te,loc,sprintf("index is %d but tuple has only %d fields",
				    i,List::length(ts)));
    }
  case ArrayType*(ta,q,ak):
    if (ak == ^array_kind.UntaggedArray)
      expr_err(te,loc,sprintf("can't safely index into untagged array"));
    res_t = ta;
  default:
    return expr_err(te,loc,
		   sprintf("subscript applied to %s (array or tuple required)",
			   typ2string(t2)));
  }
  return synth_set_typ(list_result,res_t);
}

static typ exp_typ(exp e) {
  return e.topt.v;
}

/* $(es) */
static synth tcTuple(tenv te, seg loc, <typ>Opt topt, <exp>list es) {
  _ list_result = tcExpList(te,es);
  <typ>list ts = List::map(exp_typ,es);
  <*(tqual,typ)>list fields = List::map(make_tuple_field,ts);
  return synth_set_typ(list_result,^typ.TupleType(fields));
}

static *(tqual,typ) make_tuple_field(typ t) {
  return ^(^tqual{q_const = false, q_volatile = false, q_restrict = false},t);
}

/* Compound literals, e.g., (struct foo){3,"abc"} */
static synth tcCompoundLit(tenv te, seg loc, <typ>Opt topt,
			   *(<string>Opt,tqual,typ) t,
			   <*(<designator>list,exp)>list des) {
  return expr_err(te,loc,"tcCompoundLit");
}

///////////////////// Array ({e1,...,en}) /////////////////////////
// FIX:  only a very limited class of designators (basically, the proper
// index) is supported and all of the array elements must be present.
static synth tcArray(tenv te,seg loc,<typ>Opt topt, 
		     <*(<designator>list,exp)>list des) {
  <exp>list es = List::map(snd@<<designator>list,exp>,des);
  if (topt != null) {
    switch (compress(topt.v)) {
    case ArrayType*(elt_t,_,_):
      // cast all of the elements to the element type
      for (_ es = es; es != null; es = es.tl) {
	exp e = es.hd;
	e.raw_exp = cast_exp(elt_t,new_exp(e.raw_exp,e.loc),e.loc).raw_exp;
      }
    default: 
      terr(loc,sprintf("initializer for %s is an array",typ2string(topt.v)));
    }
  }
  _ list_result = tcExpList(te,es);
  typ res_t = wildtyp();
  if (!coerce_list(te,res_t,es))
    terr(es.hd.loc,sprintf("elements of array do not all have the same type (%s)",typ2string(res_t)));
  raw_exp sz_rexp = ^raw_exp.Const(^cnst.Int(^(^sign.Unsigned,List::length(es))));
  exp sz_exp = ^exp{topt=^Opt(uint_t),raw_exp=sz_rexp,loc=loc,assigned_to=null};
  typ res_t = ^typ.ArrayType(^(res_t,empty_tqual(),^array_kind.FixedArray(sz_exp)));
  // check that any designators make sense
  for(int offset = 0; des != null; offset++, des = des.tl) {
    <designator>list ds = des.hd.1;
    if (ds != null) {
      //      if (ds.hd.tl != null)
      //	terr(ds.hd.2.loc,"only array index designators are supported");
      switch (ds.hd) {
      case FieldName(_):
	terr(loc,"only array index designators are supported");
      case ArrayElement(exp):
	tcExp(te,null,exp);
	unsigned int i = eval_const_uint_exp(exp);
	if (i != offset)
	  terr(exp.loc,
               sprintf("expecting index designator %d but found %d",
                       offset,i));
      }
    }
  }
  return synth_set_typ(list_result,res_t);
}

/* {for x < e1 : e2} */
static synth tcComprehension(tenv te,seg loc,<typ>Opt topt,
			     var x,exp bound,exp body) {
  _ esyn_bound = tcExp(te,null,bound);
  if (!coerce_uint_t(te,bound))
    terr(bound.loc,sprintf("expecting unsigned int, found %s",
                           typ2string(synth_typ(esyn_bound))));
  // add x to the environment with the type unsigned int, note it is inited
  tenv te2 = add_local_var(loc,te,x,empty_tqual(),uint_t,true);
  // if topt is present, cast the body to topt's element type
  if (topt != null) {
    switch (compress(topt.v)) {
    case ArrayType*(elt_t,_,_):
      body.raw_exp = cast_exp(elt_t,
			      new_exp(body.raw_exp,body.loc),body.loc).raw_exp;
    default:
      terr(loc,sprintf("initializer for %s is an array",typ2string(topt.v)));
    }
  }
  // type-check the body in the new environment
  _ esyn_body = tcExp(te2,null,body);
  array_kind k;
  if (is_const_exp(te2,bound)) {
    k = ^array_kind.FixedArray(bound);
  } else {
    k = ^array_kind.TaggedArray;
  }
  typ t = ^typ.ArrayType(^(synth_typ(esyn_body), empty_tqual(), k));
  // the body may never be executed -- like a while or for loop
  return synth_set_typ(loop_synth(esyn_bound,esyn_body),t);
}

//////////////////// Struct (f{e1,...,en}) ///////////////////
// FIX:
// Right now, we only allow one field name designator on an argument.
// In addition, we assume any undesignated argument is associated with
// the first field that has not yet been explicitly mentioned.  So,
// for instance, if we have:
//  struct Foo {int a,b,c,d,e;}
//  Foo{.c=3,.d=4,1,2,5};
// then this is the same as Foo{.a=1,.b=2,.c=3,.d=4,.e=5};
// Later, we should support array designators and so forth.
static synth
tcStruct(tenv te, seg loc, <typ>Opt topt,
	 *(typedef_name,opt_types,
           <*(<designator>list,exp)>list,<structdecl>Opt) arg) {
  structdecl sd;
  if (arg.4 != null)
    sd = arg.4.v;
  else {
    sd = lookup_structdecl(te,loc,arg.1);
    if (sd.name != null)
      arg.1 = sd.name.v;
  }
  // calculate the instantiation and final type
  _ inst = List::map(make_inst_var,sd.tvs);
  _ typs = List::map(snd@<tvar,typ>,inst);
  arg.2 = ^Opt(typs);
  _ res_t = ^typ.StructType(^(^Opt(arg.1),typs));
  <*(field_name,tqual,typ)>list fields;
  if (sd.fields == null) {
    fields = null;
    terr(loc,sprintf("struct %s is abstract",qvar2string(arg.1)));
  } else
    // must make copy because we do imperative removes later on
    fields = List::copy(sd.fields.v);
  // type-check all of the argument expressions in order
  _ args = arg.3;
  _ list_result = tcExpList(te,List::map(snd@<<designator>list,exp>,args));
  // for each argument find its field and make sure its type matches
  while (args != null) {
    _ ds = args.hd.1;
    _ e = args.hd.2;
    *(field_name,tqual,typ) field;
    if (ds == null) {
      // no explicit designator -- take the first field
      if (fields == null) {
	return expr_err(te,e.loc,sprintf("extra argument to struct %s",
					qvar2string(arg.1)));
      }
      field = fields.hd;
      args.hd.1 = ^list(^designator.FieldName(field.1),null);
      fields = fields.tl;
    } else {
      // make sure the explicit designator is just a field name --
      // remove that field from the list of fields
      _ d = ds.hd;
      if (ds.tl != null) terr(e.loc,"too many designators");
      switch (d) {
      case ArrayElement(e):
	return expr_err(te,e.loc,"array designators not supported here");
      case FieldName(f):
	try {
	  _ p = remove_field(f,fields);
	  field = p.1;
	  fields = p.2;
	} catch {
	case MissingField:
	  return expr_err(te,e.loc,sprintf("bad field designator %s",f));
	}
      }
    }
    // field is now found -- check that the argument is the right type.
    _ field_typ = substitute(inst,field.3);
    if (!coerce_arg(te,e,field_typ))
      terr(e.loc,sprintf("field %s of struct %s expects type %s != %s",
			    field.1,qvar2string(arg.1),typ2string(field_typ),
			    typ2string(e.topt.v)));
    args = args.tl;
  }
  if (fields != null)
    terr(loc,sprintf("struct %s is missing a value for field %s",
                     qvar2string(arg.1),fields.hd.1));
  return synth_set_typ(list_result,res_t);
}

/* f(es)   where f is an enum */
static synth
tcEnum(tenv te, seg loc, <typ>Opt topt,
       *(qvar,opt_types,opt_types,<exp>list,enumdecl,enumfield) arg) {
  // FIX: the topt arg is not used ??
  qvar f = arg.1;
  <exp>list es = arg.4;
  _ list_result = tcExpList(te,es);
  enumdecl ed = arg.5;
  enumfield ef = arg.6;
  _ all_inst = List::map(make_inst_var,ed.tvs);
  _ exist_inst = List::map(make_inst_var,ef.tvs);
  _ all_typs = List::map(snd@<var,typ>,all_inst);
  _ exist_typs = List::map(snd@<var,typ>,exist_inst);
  _ inst = List::append(all_inst,exist_inst);
  arg.2 = ^Opt(all_typs);
  arg.3 = ^Opt(exist_typs);
  typ res_t = ^typ.EnumType(^(ed.name,all_typs));
  <*(tqual,typ)>list ts = ef.typs;
  while (es != null && ts != null) {
    exp e = es.hd; es = es.tl;
    typ t = substitute(inst,ts.hd.2); 
    ts = ts.tl;
    if (!coerce_arg(te,e,t))
      terr(e.loc,
           sprintf("enum constructor %s expects argument of type %s but this argument has type %s",qvar2string(f),typ2string(t),
		   (e.topt == null) ? "?" : typ2string(e.topt.v)));
  }
  if (es != null) {
    return expr_err(te,es.hd.loc,
		    sprintf("too many arguments for enum constructor %s",
			   qvar2string(f)));
  }
  else if (ts != null) {
    return expr_err(te,loc,
		    sprintf("too few arguments for enum constructor %s",
                           qvar2string(f)));
  }
  return synth_set_typ(list_result,res_t);
}

/* f(es)   where f is an xenum */
static synth
tcXenum(tenv te, seg loc, <typ>Opt topt,
	*(qvar,opt_types,<exp>list,xenumdecl,enumfield) arg) {
  qvar f = arg.1;
  <exp>list es = arg.3;
  _ list_result = tcExpList(te,es);
  xenumdecl xd = arg.4;
  enumfield ef = arg.5;
  _ exist_inst = List::map(make_inst_var,ef.tvs);
  _ exist_typs = List::map(snd@<var,typ>,exist_inst);
  arg.2 = ^Opt(exist_typs);
  typ res_t = ^typ.XenumType(xd.name);
  <*(tqual,typ)>list ts = ef.typs;
  while (es != null && ts != null) {
    exp e = es.hd; es = es.tl;
    typ t = substitute(exist_inst,ts.hd.2); 
    ts = ts.tl;
    if (!coerce_arg(te,e,t))
      terr(e.loc,sprintf("xenum constructor %s expects argument of type %s but this argument has type %s",qvar2string(f),typ2string(t),typ2string(e.topt.v)));
  }
  if (es != null)
    terr(es.hd.loc,sprintf("too many arguments for xenum constructor %s",
                           qvar2string(f)));
  else if (ts != null)
    terr(es.hd.loc,sprintf("too few arguments for xenum constructor %s",
                           qvar2string(f)));
  return synth_set_typ(list_result,res_t);

}

/* ({ s }) */
static synth tcStmtExp(tenv te, seg loc, <typ>Opt topt, stmt s) {
  _ ssyn = tcStmt(te,s);
  _ topt = find_stmt_typ(s);
  if (topt == null) {
    return expr_err(te,loc,"cannot determine type of statement expression");
  }
  return synth_set_typ(ssyn,topt.v);
}

static <typ>Opt find_stmt_typ(stmt s) {
  switch (s.raw_stmt) {
  case Exp(e): return e.topt;
  case Seq*(s1,s2): return find_stmt_typ(s2);
  case Decl*(d,s1): return find_stmt_typ(s1);
  default: return null;
  }
}


/* codegen(fd) */
static synth tcCodegen(tenv te, seg loc, <typ>Opt topt, fndecl fd) {
  typ t = fndecl2typ(fd);
  /*
  check_fundecl_valid_type(te,loc,fd);
  tenv te2 = code_gen_tenv(fd,te);
  tcFnDecl(te2,loc,fd);
  */
  return standard_synth(te,t);
}

static void tcFnDecl(tenv te, seg loc, <typ>Opt topt, fndecl fd) {
  terr(loc,"tcFnDecl");
  return;
}

/* fill(e) */
static synth tcFill(tenv te, seg loc, <typ>Opt topt, exp e) {
  return expr_err(te,loc,"tcFill");
//  switch te.local {
//  case Frame(p):
//    // NB: assignments are not tracked in fills
//    return base_synth(te,tcExp(fill_te(te),e).typ);
//  case Hidden(_):
//    return terr(loc,"fill cannot be used while codegen is in cut");
//  case Outermost(_):
//    return terr(loc,"fill can only be used within codegen");
//  }
}

/* Unary primops like -e, !e, etc. */
static typ tcUnPrimop(tenv te, seg loc, <typ>Opt topt, primop p, exp e) {
  typ t = compress(e.topt.v);
  switch (p) {
  case Plus:
    if (!arithmetic_promote(te,e)) {
      terr(loc,sprintf("expecting arithmetic type but found %s",
			  typ2string(t)));
    }
    return e.topt.v;
  case Minus:
    if (!arithmetic_promote(te,e)) {
      terr(loc,sprintf("expecting arithmetic type but found %s",
			  typ2string(t)));
    }
    return e.topt.v;
  case Not:
    if (!coerce_bool_t(te,e))
      terr(loc,sprintf("expecting bool but found %s",typ2string(t)));
    return bool_t;
  case Bitnot:
    if (!integral_promote(te,e)) {
      terr(loc,sprintf("expecting integral type but found %s",
			  typ2string(t)));
    }
    return e.topt.v;
  case Size:
    switch (t) {
    case ArrayType*(_,_,ak):
      switch (ak) {
      case UntaggedArray:
	terr(loc,"size not applicable to indetermine arrays");
      default: ; // skip
      }
    default:
      terr(loc,sprintf("size requires array type, not %s",typ2string(t)));
    }
    return uint_t;
  default:
    return impos("Non-unary primop");
  }
}

/* Binary primops like e1+e2, e1>>e2, etc. */
static typ tcBinPrimop(tenv te, seg loc, <typ>Opt topt, 
		       primop p, exp e1, exp e2) {
  typ t;
  switch (p) {
    // FIX:  Plus and Minus should allow arrays
  case Plus:       t = tcArithBinop(te,loc,topt,e1,e2);
  case Times:      t = tcArithBinop(te,loc,topt,e1,e2);
  case Minus:      t = tcArithBinop(te,loc,topt,e1,e2);
  case Div:        t = tcArithBinop(te,loc,topt,e1,e2);
  case Mod:        t = tcIntegralBinop(te,loc,topt,e1,e2);
  case Eq:         t = tcAnyBinop(te,loc,topt,e1,e2);
  case Neq:        t = tcAnyBinop(te,loc,topt,e1,e2);
  case Gt:         t = tcAnyBinop(te,loc,topt,e1,e2);
  case Lt:         t = tcAnyBinop(te,loc,topt,e1,e2);
  case Gte:        t = tcAnyBinop(te,loc,topt,e1,e2);
  case Lte:        t = tcAnyBinop(te,loc,topt,e1,e2);
  case Bitand:     t = tcIntegralBinop(te,loc,topt,e1,e2);
  case Bitor:      t = tcIntegralBinop(te,loc,topt,e1,e2);
  case Bitxor:     t = tcIntegralBinop(te,loc,topt,e1,e2);
  case Bitlshift:  t = tcIntegralBinop(te,loc,topt,e1,e2);
  case Bitlrshift: t = tcIntegralBinop(te,loc,topt,e1,e2);
  case Bitarshift: t = tcIntegralBinop(te,loc,topt,e1,e2);
  default:
    t = (raise Failure("bad binary primop"));
  }
  return t;
}

static typ tcArithBinop(tenv te, seg loc, <typ>Opt topt, exp e1, exp e2) {
  if (!arithmetic_promote(te,e1)) {
    terr(e1.loc,sprintf("expecting arithmetic type but found %s",
                        typ2string(e1.topt.v)));
    return wildtyp();
  }
  if (!arithmetic_promote(te,e2)) {
    terr(e2.loc,sprintf("expecting arithmetic type but found %s",
                        typ2string(e2.topt.v)));
    return wildtyp();
  }
  typ t1 = compress(e1.topt.v);
  typ t2 = compress(e2.topt.v);
  typ res_t = max_arithmetic_type(t1,t2);
  // these casts should always succeed
  unchecked_cast(te,e1,res_t);
  unchecked_cast(te,e2,res_t);
  return res_t;
}

static typ tcIntegralBinop(tenv te, seg loc, <typ>Opt topt, exp e1, exp e2) {
  if (!integral_promote(te,e1)) {
    terr(e1.loc,sprintf("expecting integral type but found %s",
                        typ2string(e1.topt.v)));
    return wildtyp();
  }
  if (!integral_promote(te,e2)) {
    terr(e2.loc,sprintf("expecting integral type but found %s",
                        typ2string(e1.topt.v)));
    return wildtyp();
  }
  typ t1 = compress(e1.topt.v);
  typ t2 = compress(e2.topt.v);
  typ res_t = max_arithmetic_type(t1,t2);
  // these casts should always succeed
  unchecked_cast(te,e1,res_t);
  unchecked_cast(te,e2,res_t);
  return res_t;
}

static typ tcAnyBinop(tenv te, seg loc, <typ>Opt topt, exp e1, exp e2) {
  bool e1_is_unboxed_arith = comparison_promote(te,e1);
  bool e2_is_unboxed_arith = comparison_promote(te,e2);
  typ t1 = compress(e1.topt.v);
  typ t2 = compress(e2.topt.v);
  if (e1_is_unboxed_arith && e2_is_unboxed_arith) {
    typ res_t = max_arithmetic_type(t1,t2);
    unchecked_cast(te,e1,t1);
    unchecked_cast(te,e2,t2);
  } else {
    if (!unify(t1,t2)) {
      terr(loc,sprintf("comparison not allowed between %s and %s",
                       typ2string(t1),typ2string(t2)));
      return wildtyp();
    }
  }
  return bool_t;
}

bool is_const_exp(tenv te, exp e) {
  return cnst_exp(te,false,e);
}

// FIX: there are other expressions we could allow, such as 
// &(x.y) or &(x[0]) that we do not support here...
static bool cnst_exp(tenv te, bool var_okay, exp e) {
  switch (e.raw_exp) {
  case Const(_):
    return true;
  case Var(qv): 
    // NB: top-level function names are "constant" 
    // Fix: what about arrays?
    switch (lookup_ordinary(te, e.loc, qv)) {
    case GlobalRes*(_,vi):
      switch (compress(vi.t)) {
      case FnType(_): return true;
      default: ; // skip
      }
    default: ; // skip
    }
    return var_okay;
  case Primop*(p,es):
    return (List::forall_c(is_const_exp,te,es));
  case Conditional*(e1,e2,e3):
    return (cnst_exp(te,false,e1) && cnst_exp(te,false,e2) && 
	    cnst_exp(te,false,e3));
  case SeqExp*(e1,e2):
    return (cnst_exp(te,false,e1) && cnst_exp(te,false,e2));
  case Instantiate*(e,_):
    return cnst_exp(te,var_okay,e);
  case Cast*(t,e):
    // Fix:  not clear that we should allow boxing/unboxing conversions...
    return cnst_exp(te,var_okay,e);
  case Address(e):
    return cnst_exp(te,true,e);
  case Sizeof(t):
    return true;
  case Tuple(es):
    for (; es != null; es = es.tl)
      if (!cnst_exp(te,false,es.hd)) return false;
    return true;
  case Array(des):
    for (; des != null; des = des.tl)
      if (!cnst_exp(te,false,des.hd.2)) return false;
    return true;
  case Struct*(_,_,des,_):
    for (; des != null; des = des.tl)
      if (!cnst_exp(te,false,des.hd.2)) return false;
    return true;
  case Enum*(_,_,_,es,_,_):
    for (; es != null; es = es.tl)
      if (!cnst_exp(te,false,es.hd)) return false;
    return true;
  case Xenum*(_,_,es,_,_):
    for (; es != null; es = es.tl)
      if (!cnst_exp(te,false,es.hd)) return false;
    return true;
  default:
    return false;
  }
}
