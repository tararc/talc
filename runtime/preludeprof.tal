; TAL IMPLEMENTATION test
; This file was generated by POP TALC

;; Prelude for use by POP_IN_POP compiler.
	INCLUDE	TAL.INC
	_begin_TAL
	TAL_IMPORT	pop_runtimenew.tali
	TAL_IMPORT	preludeprof_i.tali
	TAL_EXPORT	preludenew_e.tali
	TAL_EXPORT	tal_prog.tali

	TYPE	<exn =Exist[c:Tm].^*[(^T^rw(c)*[B4^rw])^r,c]>
	TYPE	<str =Exist[?sz:Sint].^*[S(?sz)^r,(^*[array(?sz,B1^rw)])^r]>

	TYPE	<wrapper_t = code{EAX:exn,ESP:sptr se}>

	CODE

_pop_exn_handler_wrapper:
LABELTYPE <wrapper_t>
	PUSH	_pop_exn_handler_wrapper
	MOV	EBP,ESP
	MOV	EBX,EAX
	MOV	ESI,0
	MOV	EDI,0
	CALL	tapp(_prof_end,<EBX,B4,B4,se,se,cap[],cap[]>)
	MOV	DWORD PTR[ESP+0],EBX
	CALL	_pop_exn_handler_verbose
	JMP	_pop_never_null

; C expects arguments on the stack not in EAX
; so our handler pop_exn_handler which is actually a C function
; cannot get the exception to manipulate it.
; Therefore we add a new bogus block which simply pushes
; EAX before calling pop_exn_handler.
;
; For doubles we need the stack fo be doubleword aligned.  Aligning the stack
; requires pushing a variable amount of stuff on the stack.  Before we can call
; tal_exit we have to clear this stuff off. So we push the stack pointer on the
; stack.
_tal_main:
LABELTYPE <code{ESP:sptr se}>
	PUSH	_pop_exn_handler_wrapper
	MOV	EBP,ESP
	MOV 	EBX,ESP
	COERCE	subsume(<B4>,EBX)
	AND	EBX,7
	CMP	EBX,0
; If stack is doubleword aligned.
	JE	tapp(std_start,<se>)
	CMP     EBX,4
	JE	word_align
; If the stack isn't word aligned we give up.
	MOV	DWORD PTR[ESP+0], 1
	JMP	tapp(_tal_exit,<se>)
		
word_align:
	; Stack is word_aligned.
	PUSH 	0
	JMP	tapp(std_start,<junk4::se>)

std_start: 
LABELTYPE <All[s1:Ts].code{ESP:sptr s1#wrapper_t::se, EBP: sptr wrapper_t::se}>
	MOV	EBX,0
	MOV	ESI,EBX
	MOV	EDI,EBX
	CALL	tapp(_prof_init,<B4,B4,B4,s1,se,cap[],cap[]>)
	CALL	tapp(_pop_main,<B4,B4,B4,s1,se,cap[],cap[]>)
	MOV	EBX,EAX
	CALL	tapp(_prof_end,<EAX,B4,B4,s1,se,cap[],cap[]>)
	MOV	EAX,EBX
	MOV	ESP, EBP
	MOV	DWORD PTR[ESP+0],0
	JMP	tapp(_tal_exit,<se>)
	
nullFailure$2:
	MOV	EAX,DWORD PTR [NullPointer?exn?pkt+0]
	MOV	ESP,EBP
	RETN
unionFailure$3:
	MOV	EAX,DWORD PTR [UnionVariant?exn?pkt+0]
	MOV	ESP,EBP
	RETN

	DATA
ArrayBounds?exn:
LABELTYPE <^T^rw(B4^rw)*[B4^rw]>
	DD	subsume(<B4>,0)
?xArrayBounds?exn?pkt:
LABELTYPE <exn>
COERCE	pack(<B4^rw>,?,<exn>)
	DD	ArrayBounds?exn
	DD	subsume(<B4>,0)
ArrayBounds?exn?pkt:
LABELTYPE <^*[exn^rw]>
	DD	?xArrayBounds?exn?pkt

NullPointer?exn:
LABELTYPE <^T^rw(B4^rw)*[B4^rw]>
	DD	subsume(<B4>,0)
?xNullPointer?exn?pkt:
LABELTYPE <exn>
COERCE	pack(<B4^rw>,?,<exn>)
	DD	NullPointer?exn
	DD	subsume(<B4>,0)
NullPointer?exn?pkt:
LABELTYPE <^*[exn^rw]>
	DD	?xNullPointer?exn?pkt

UnionVariant?exn:
LABELTYPE <^T^rw(B4^rw)*[B4^rw]>
	DD	subsume(<B4>,0)
?xUnionVariant?exn?pkt:
LABELTYPE <exn>
COERCE	pack(<B4^rw>,?,<exn>)
	DD	UnionVariant?exn
	DD	subsume(<B4>,0)
UnionVariant?exn?pkt:
LABELTYPE <^*[exn^rw]>
	DD	?xUnionVariant?exn?pkt

	_end_TAL
	END








