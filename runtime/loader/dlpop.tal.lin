; TAL IMPLEMENTATION bar
; This file was generated by TALC
	INCLUDE	TAL.INC
	_begin_TAL


	TAL_IMPORT	pop_runtime.tali
	TAL_IMPORT 	loader.tali
	TAL_IMPORT	dlpop_i.tali

	TAL_EXPORT	dlpop_e.tali

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;;     LX version of popcorn types
;;;;
;;;;

kind <var = Sint>
kind <unit = *[] >
kind <bool = +[ unit,     \ ; false
		unit ] >    ; true
kind <size = +[ unit,     \ ; B1
	        unit,     \ ; B2
	        unit ]>     ; B4

reckind <typlist = +[ unit, *[typ, typlist]]>
andkind <typ = +[ unit,      \ ; exn 
	       *[bool,size], \ ; int 
	       unit,      \ ; bool
               unit,      \ ; string 
	       unit,      \ ; char
	       typ,       \ ; array (can't specify size)
	       *[typ,typlist], \ ; mono-morphic functions (returning a value)
	       typlist, \   ; mono-morphic functions (returning void)
	       typlist \   ; tuples
 ]>
              ; need structs, unions
kind <utyplist = +[ unit, *[typ, typlist]]>
kind <utyp =  +[ unit,      \ ; exn 
	       *[bool,size], \ ; int 
	       unit,      \ ; bool
               unit,      \ ; string 
	       unit,      \ ; char
	       typ,       \ ; array (can't specify size)
               *[typ,typlist], \ ; mono functions
	       typlist, \   ;  mono-morphic functions (returning void)
	       typlist]>    ; tuples

reckind <Tlist  = +[unit, *[T, Tlist]]>
kind    <uTlist = +[unit, *[T, Tlist]]>

; Abbreviations for the types of popcorn functions
type < fntype = fn ret:T4 args:Ts. \
 (All[s1:Ts s2:Ts e1:Tcap e2:Tcap]. code {cap: &[e1,e2], \
   EBP: sptr (?E s2 e2), ESP: sptr (?S ret (args@s1) s2 e1 e2)@(?E s2 e2)})>
type < vfntype = fn args:Ts. \
 (All[s1:Ts s2:Ts e1:Tcap e2:Tcap]. code {cap: &[e1,e2], \
   EBP: sptr (?E s2 e2), ESP: sptr (?Sv (args@s1) s2 e1 e2)@(?E s2 e2)})>

type <crexn = roll [typ] (inj 0 [] [utyp])>
type <crint = fn a:bool b:size. roll [typ] (inj 1 [a,b] [utyp])>
type <crbool = roll [typ] (inj 2 [] [utyp])>
type <crstring = roll [typ] (inj 3 [] [utyp])>
type <crchar = roll [typ] (inj 4 [] [utyp])>
type <crarray = fn a:typ. roll [typ] (inj 5 a [utyp])>
type <crfn = fn a:typ b:typlist. roll [typ] (inj 6 [a,b] [utyp])>
type <crvfn = fn a:typlist. roll [typ] (inj 7 a [utyp])>
type <crtuple = fn a:typlist . roll [typ] (inj 8 a [utyp])>

type <crnull = roll [typlist] (inj 0 [] [utyplist])>
type <crcons = fn a: typ b:typlist. roll [typlist] (inj 1 [a,b] [utyplist])>

type <crfalse = inj 0 [] [bool]>
type <crtrue = inj 1 [] [bool]>

type <crb1 = inj 0 [] [size]>
type <crb2 = inj 1 [] [size]>
type <crb4 = inj 2 [] [size]>

; Produce the TAL type from the popcorn type
primrec <interpTprod : typlist -!> Tm = fn a:+[ *[], *[typ, typlist]].  \
	case (a) b [ *[], \
	             *[ (interp (b.0))^rw, interpTprod (b.1)]]>
andprim <interpTs : typlist -!> Ts = fn a:+[ *[], *[typ, typlist]].  \
	case (a) b [ se, \
	             (interp b.0)::(interpTs (b.1))]>
andprim <interp : typ -!> T4 = fn a:+[ unit,      \ ; Void 
	       *[bool,size], \ ; int 
	       unit,      \ ; bool
               unit,      \ ; string 
	       unit,      \ ; char
	       typ,       \ ; array (can't specify size)
               *[typ,typlist], \ ; mono functions
	       typlist,   \
	       typlist] . \
	(case (a) b [ ?exn,                \  ; exception
	   	      B4,                     \  ; int 	
	              ^T[0,1], 		      \  ; bool
		      ?str, 		      \  ; str
		      B4, 	 	      \  ; char 
		      ?arr (interp b),         \  ; array
		      fntype (interp (b.0)) (interpTs (b.1)), \
		      vfntype (interpTs b), \
                      ^(interpTprod b)])>

primrec < unrol_typlist : typlist -!> +[unit, *[typ, typlist]] =  \
	fn a: +[unit, *[typ, typlist]] . a >
andprim <unrol_typ : typ -!> \
	    +[ unit,      \ ; exception
	       *[bool,size], \ ; int 
	       unit,      \ ; bool
               unit,      \ ; string 
	       unit,      \ ; char
	       typ,       \ ; array (can't specify size)
               *[typ,typlist], \ ; mono functions
	       typlist,        \ ; mono void returning functions
	       typlist]  = \
       fn a:+[ unit,      \ ; exception
	       *[bool,size], \ ; int 
	       unit,      \ ; bool
               unit,      \ ; string 
	       unit,      \ ; char
	       typ,       \ ; array (can't specify size)
               *[typ,typlist], \ ; mono functions
	       typlist,     \
	       typlist] . a>
;
; Create the type of the representation of it. 
type    < repbool = fn a:bool . S (case (a) b [0, 1])>
type    < repsize = fn a:size . S (case (a) b [0, 1, 2])>
type    < rep = rec (   \
	   rep_typ : typ -!> T4. fn a: typ. \
	     ^+[ *[S(0)^r, (case (unrol_typ a) b			       \
		     [ B4, void[T4], void[T4], void[T4], void[T4],        \
	               void[T4], void[T4], void[T4], void[T4]])^rw],   \
	        *[S(1)^r, (case (unrol_typ a) b			       \
		     [ void[T4], ^*[(repbool (b.0))^rw, (repsize (b.1))^rw], \
					   void[T4], void[T4], void[T4],        \
	               void[T4], void[T4], void[T4], void[T4]])^rw],   \
	        *[S(2)^r, (case (unrol_typ a) b			       \
		     [ void[T4], void[T4], B4, void[T4], void[T4],        \
	               void[T4], void[T4], void[T4], void[T4]])^rw],   \
	        *[S(3)^r, (case (unrol_typ a) b			       \
		     [ void[T4], void[T4], void[T4], B4, void[T4],       \
	              void[T4], void[T4], void[T4], void[T4]])^rw],   \
	        *[S(4)^r, (case (unrol_typ a) b			       \
		     [ void[T4], void[T4], void[T4], void[T4],         \
	               B4,void[T4], void[T4], void[T4], void[T4]])^rw],   \
	        *[S(5)^r, (case (unrol_typ a) b			       \
		     [ void[T4], void[T4], void[T4], void[T4],         \
	               void[T4], rep_typ b, void[T4],  void[T4], void[T4]])^rw],   \
	        *[S(6)^r, (case (unrol_typ a) b			   \    
		     [ void[T4], void[T4], void[T4], void[T4],     \    
	               void[T4], void[T4], ^*[(rep_typ (b.0))^rw,  \ 
			(rep_typlist (b.1))^rw],  void[T4], void[T4]])^rw],   \ 
	        *[S(7)^r, (case (unrol_typ a) b			       \
		     [ void[T4], void[T4], void[T4], void[T4],         \
	               void[T4], void[T4], void[T4], rep_typlist b, void[T4] ])^rw],   \
	        *[S(8)^r, (case (unrol_typ a) b			       \
		     [ void[T4], void[T4], void[T4], void[T4],         \
	               void[T4], void[T4], void[T4], void[T4], rep_typlist b])^rw]],  \
	   rep_typlist : typlist -!> T4 . fn a: typlist. \
	      ^+[*[S(0)^r, (case (unrol_typlist a) b \
		     [ B4, void[T4] ])^rw],          \
		*[S(1)^r, (case (unrol_typlist a) b \
		     [ void[T4], ^*[(rep_typ (b.0))^rw, \
		                    (rep_typlist (b.1))^rw]])^rw]])>
type <reptyp = rep.0>
type <reptyplist = rep.1>

;; an abbreviation for the type of the entries in the symbol table.
TYPE 	<entry = Exist[b:typ].^*[?str^rw,(reptyp b)^rw,(interp b)^rw]>
;; an abbreviation for the type of the function init. In R-popcorn it should be:
;; void init (a lookup_symbol<a>(string, R(a)), 
;;            void add_symbol<a>(string, R(a), a));
TYPE 	<initfntype = (All[s1:Ts s2:Ts e1:Tcap e2:Tcap]. \
	code {cap: &[e1,e2], \
	  EBP: sptr (?E s2 e2), \
	  ESP: sptr (?Sv \
	    (All[va:typ s1:Ts s2:Ts e1:Tcap e2:Tcap]. \ ; lookup fun
	      code {cap: &[e1,e2], \
	        EBP: sptr (?E s2 e2), \
	        ESP: sptr (?S (interp va) ?str:: \
	          (reptyp va)::s1 s2 e1 e2)@(?E s2 e2)}):: \
	    (All[va:typ s1:Ts s2:Ts e1:Tcap e2:Tcap]. \ ; update fun
	      code {cap: &[e1,e2], \
	        EBP: sptr (?E s2 e2), \
	        ESP: sptr (?Sv ?str:: \
		  (reptyp va)::(interp va)::s1 s2 e1 e2)@(?E s2 e2)})::s1 \
	  s2 e1 e2)@(?E s2 e2)})>                       ; rest of stack
TYPE 	<inittype = *[initfntype^rw]>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;   
;;;;   Type labels -- implement the type handle
;;;;
	TYPE	<bogus_option$1 :T4 = ^T[0]>
	TYPE	<handle_t? :T4 = ^`handle_t?mem>
	TYPE	<handle_t?mem :Tm 8 = *[(`List?list? entry)^rw,(`List?list? entry)^rw]>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;;    CODE SEGMENT
;;;;

	CODE
;;;;
;;;;   Helper functions: 
;;;;

;;;;   passed to init functions to find symbols in the global table
;;;;   I put dlpop? in its name so it could be exported instead of dlsym,
;;;;   and not conflict.
_dlpop?lookup_symbol:
LABELTYPE <All[va:typ s1:Ts s2:Ts e1:Tcap e2:Tcap]. \
	    code {cap: &[e1,e2], \
	          EBP: sptr (?E s2 e2), \
		  ESP: sptr (?S (interp va) ?str::(reptyp va)::s1 \
		            s2 e1 e2)@(?E s2 e2)}>
	PUSH	DWORD PTR [ESP+8]
	PUSH	DWORD PTR [ESP+8]
	PUSH	rollsum(<`List?list? entry>,0)
	PUSH	DWORD PTR [_symbol_table]
	CALL	tapp(_find,<va,ESP 4 7 s1,EBP 1,e1,e2>)
	ADD	ESP,16
	RETN

;;;;  passed to init functions to add symbols at the beginning of the symbol table
_add_symbol:
LABELTYPE <All[va:typ s1:Ts s2:Ts e1:Tcap e2:Tcap]. \
	    code {cap: &[e1,e2], \
	    EBP: sptr (?E s2 e2), \
	    ESP: sptr (?Sv ?str::(reptyp va)::(interp va)::s1 s2 e1 e2)@(?E s2 e2)}>
	PUSH	DWORD PTR [_symbol_table]
	MALLOC	mptr$35,12
	MOV	EBX,EAX
	MOV	EAX,[ESP+8]
	MOV	[EBX],EAX
	MOV	EAX,[ESP+12]
	MOV	[EBX+4],EAX
	MOV	EAX,[ESP+16]
	MOV	[EBX+8],EAX
	FORGETUNIQUE	mptr$35
	COERCE  pack(<va>,forgetname(EBX),<entry>)
	PUSH	EBX
	CALL	tapp(_List?cons,<entry,ESP 2 6 s1,EBP 1,e1,e2>)
	ADD	ESP,8
	MOV	DWORD PTR [_symbol_table],EAX
	RETN

;;;;   Helper function for finding symbols. Takes a pointer to the start of
;;;;   the list, and a pointer to the end, and looks between them.
_find:
LABELTYPE <All[va:typ s1:Ts s2:Ts e1:Tcap e2:Tcap]. \
	    code {cap: &[e1,e2], \
	    EBP: sptr (?E s2 e2), \
	    ESP: sptr (?S (interp va) (`List?list? entry):: \
	      (`List?list? entry)::?str::(reptyp va)::s1 s2 e1 e2)@(?E s2 e2)}>
	PUSH	DWORD PTR [ESP+4]
	PUSH	rollsum(<`Core?Opt? (interp va)>,0)
	JMP	whiletest$4
whilebody$3:
LABELTYPE <All[va:typ s1:Ts s2:Ts e1:Tcap e2:Tcap]. \
	    code {cap:&[e1,e2], \
	      EBP: sptr (?E s2 e2), \
	      ESP: sptr (`Core?Opt? (interp va))::(`List?list? entry):: \
	        (?S (interp va) (`List?list? entry)::(`List?list? entry):: \
		?str::(reptyp va)::s1 s2 e1 e2)@(?E s2 e2)}>
	PUSH	subsume(<B4>,0)
	PUSH	DWORD PTR [ESP+24]
	MOV	EAX,unroll(unroll([ESP+12]))
	NAMEOBJ	n$9,EAX
	CMP	EAX,0
	JE	_pop_never_null
	COERCE	forgetname(EAX)
	REMOVENAME	n$9
	MOV	EAX,[EAX]
	unpack	vb,EAX,EAX
	PUSH	DWORD PTR [EAX]
	CALL	tapp(_Core?strcmp,<ESP 2 10 s1,EBP 1,e1,e2>)
	ADD	ESP,8
	POP	ECX
	CMP	EAX,ECX
	JNE	iffalse$7
iftrue$6:
	MOV	EAX,unroll(unroll([ESP+4]))
	NAMEOBJ	n$10,EAX
	CMP	EAX,0
	JE	_pop_never_null
	COERCE	forgetname(EAX)
	REMOVENAME	n$10
	MOV	EAX,[EAX]
	unpack	vb,EAX,EAX
	PUSH	DWORD PTR [ESP+24]
	PUSH	DWORD PTR [EAX+4]
	PUSH	DWORD PTR [EAX+8]

	CALL	tapp(_cast,<vb,va,ESP 3 10 s1,EBP 1,e1,e2>)
	ADD	ESP,12
	MOV	[ESP],EAX
	MOV	EAX,[ESP]
	COERCE 	unroll(unroll(EAX))
	NAMEOBJ	n, EAX
	CMP	EAX,0
	JNE	iffalse$13
iftrue$12:
	PUSH	DWORD PTR [ESP+20]
	MALLOC	mptr$15,8
	POP	EBX
	MOV	[EAX+4],EBX
	MOV	EBX,WrongType?exn
	MOV	[EAX],EBX
	FORGETUNIQUE	mptr$15
	COERCE	pack(<?str^r>,forgetname(EAX),<?exn>)
	MOV	ESP,EBP
	POP	EBX
	JMP	EBX
iffalse$13:
	MOV	EAX,forgetname(EAX)
	MOV	EAX,[EAX]	
	ADD	ESP,8
	RETN
iffalse$7:
	MOV	EAX,unroll(unroll([ESP+4]))
	NAMEOBJ	n$17,EAX
	CMP	EAX,0
	JE	_pop_never_null
	COERCE	forgetname(EAX)
	REMOVENAME	n$17
	MOV	EAX,[EAX+4]
	MOV	[ESP+4],EAX
ifend$8:
whiletest$4:
	MOV	ECX,[ESP+16]
	MOV	EAX,[ESP+4]
	CMP	EAX,ECX
	JNE	tapp(whilebody$3,<va,s1,s2,e1,e2>)
whileend$5:
	PUSH	DWORD PTR [ESP+20]
	MALLOC	mptr$18,8
	POP	EBX
	MOV	[EAX+4],EBX
	MOV	EBX,SymbolNotFound?exn
	MOV	[EAX],EBX
	FORGETUNIQUE	mptr$18
	COERCE	pack(<?str^r>,forgetname(EAX),<?exn>)
	MOV	ESP,EBP
	POP	EBX
	JMP	EBX

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;;		Exported functions
;;;;

_dlinit:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2), \
	ESP: sptr (?Sv (initfntype)::s1 s2 e1 e2)@(?E s2 e2)}>
	PUSH	_add_symbol
	PUSH	_dlpop?lookup_symbol
	MOV	EAX,[ESP+12]
	CALL	tapp(EAX,<ESP 2 4 s1,EBP 1,e1,e2>)
	ADD	ESP,8
	RETN


_dlsym:
LABELTYPE <All[va:typ s1:Ts s2:Ts e1:Tcap e2:Tcap]. \
	    code {cap: &[e1,e2], \
	      EBP: sptr (?E s2 e2), \
	      ESP: sptr (?S (interp va) `handle_t?::?str::(reptyp va)::s1 \
	        s2 e1 e2)@(?E s2 e2)}>
	PUSH	DWORD PTR [ESP+12]
	PUSH	DWORD PTR [ESP+12]
	MOV	EAX,unroll(unroll([ESP+12]))
	PUSH	DWORD PTR [EAX+4]
	MOV	EAX,unroll(unroll([ESP+16]))
	PUSH	DWORD PTR [EAX]
	CALL	tapp(_find,<va,ESP 4 8 s1,EBP 1,e1,e2>)
	ADD	ESP,12
	ADD	ESP,4
	RETN
_dlopen:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap]. \
	    code {cap: &[e1,e2], \
	      EBP: sptr (?E s2 e2), \
	      ESP: sptr (?S `handle_t? ?str::s1 s2 e1 e2)@(?E s2 e2)}>
	PUSH	subsume(<B4>,0)
	MALLOC	mptr$19,8
	MOV	EBX,EAX
	MOV	DWORD PTR [EBX],rollsum(<`List?list? entry>,0)
	MOV	DWORD PTR [EBX+4],rollsum(<`List?list? entry>,0)
	FORGETUNIQUE	mptr$19
	PUSH	roll(<`handle_t?>,roll(<^`handle_t?mem>,forgetname(EBX)))

	PUSH	string$20
	PUSH	DWORD PTR [ESP+16]
	CALL	tapp(_Core?strconcat,<ESP 2 6 s1,EBP 1,e1,e2>)
	ADD	ESP,4
	MOV	[ESP],EAX
	PUSH	string$21
	PUSH	DWORD PTR [ESP+20]
	CALL	tapp(_Core?strconcat,<ESP 2 7 s1,EBP 1,e1,e2>)
	ADD	ESP,4
	MOV	[ESP],EAX
	PUSH	string$22
	PUSH	DWORD PTR [ESP+8]
	CALL	tapp(_Core?file_open,<ESP 2 8 s1,EBP 1,e1,e2>)
	ADD	ESP,4
	MOV	[ESP],EAX
	PUSH	string$23
	PUSH	DWORD PTR [ESP+8]
	CALL	tapp(_Core?file_open,<ESP 2 9 s1,EBP 1,e1,e2>)
	ADD	ESP,4
	MOV	[ESP],EAX
	PUSH	DWORD PTR [ESP+12]
	CALL	tapp(_Core?file_length,<ESP 1 9 s1,EBP 1,e1,e2>)
	MOV	[ESP],EAX
	PUSH	DWORD PTR [ESP]
	CALL	tapp(_Core?new_string,<ESP 1 10 s1,EBP 1,e1,e2>)
	MOV	[ESP],EAX
	PUSH	DWORD PTR [ESP+16]
	CALL	tapp(_Core?file_length,<ESP 1 11 s1,EBP 1,e1,e2>)
	MOV	[ESP],EAX
	PUSH	DWORD PTR [ESP]
	CALL	tapp(_Core?new_string,<ESP 1 12 s1,EBP 1,e1,e2>)
	MOV	[ESP],EAX
	PUSH	DWORD PTR [ESP+12]
	PUSH	subsume(<B4>,0)
	PUSH	DWORD PTR [ESP+16]
	PUSH	DWORD PTR [ESP+32]
	CALL	tapp(_f_string_read,<ESP 4 16 s1,EBP 1,e1,e2>)
	ADD	ESP,16
	PUSH	DWORD PTR [ESP+20]
	CALL	tapp(_Core?file_close,<ESP 1 13 s1,EBP 1,e1,e2>)
	ADD	ESP,4
	PUSH	DWORD PTR [ESP+4]
	PUSH	subsume(<B4>,0)
	PUSH	DWORD PTR [ESP+8]
	PUSH	DWORD PTR [ESP+28]
	CALL	tapp(_f_string_read,<ESP 4 16 s1,EBP 1,e1,e2>)
	ADD	ESP,16
	PUSH	DWORD PTR [ESP+16]
	CALL	tapp(_Core?file_close,<ESP 1 13 s1,EBP 1,e1,e2>)
	ADD	ESP,4
	PUSH	DWORD PTR [_symbol_table]
	MOV	EAX,[ESP+36]
	MOV	EBX,EAX
	POP	EAX
	COERCE	unroll(unroll(EBX))
	MOV	[EBX+4],EAX
	PUSH	EBP
	PUSH	string$30
	PUSH	DWORD PTR [ESP+8]
	PUSH	DWORD PTR [ESP+20]
	CALL	tapp(_tal_load,<inittype,ESP 3 16 (s1@(code {cap: e2,EAX: ?exn,ESP: sptr s2})::s2),e1,e2>)
	ADD	ESP,12
	POP	EBP
	NAMEOBJ	p, EAX
	CMP	EAX,0
	JNE	iffalse$32
iftrue$31:
	PUSH	0
	MALLOC	mptr$34,8
	POP	EBX
	MOV	[EAX+4],EBX
	MOV	EBX,FailsTypeCheck?exn
	MOV	[EAX],EBX
	FORGETUNIQUE	mptr$34
	COERCE	pack(<B4^r>,forgetname(EAX),<?exn>)
	MOV	ESP,EBP
	POP	EBX
	JMP	EBX
iffalse$32:
ifend$33:
	COERCE	 forgetname(EAX)
	MOV	EAX,[EAX]
	PUSH	_add_symbol
	PUSH	_dlpop?lookup_symbol
	CALL	tapp(EAX,<ESP 2 14 s1,EBP 1,e1,e2>)
	ADD	ESP,8
	MOV	EAX,[ESP+32]
	COERCE	unroll(unroll(EAX))
	MOV	EBX,[_symbol_table]
	MOV	[EAX],EBX
	MOV	EAX,[ESP+32]
	ADD	ESP,40
	RETN
;;;;;
;;;;; _dlclose 
;;;;; 

_dlclose:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap]. \
	  code {cap: &[e1,e2], \
	    EBP: sptr (?E s2 e2), \
	    ESP: sptr (?Sv `handle_t?::s1 s2 e1 e2)@(?E s2 e2)}>
	PUSH	DWORD PTR [_symbol_table]
	PUSH	rollsum(<`List?list? entry>,0)
	PUSH	rollsum(<`List?list? entry>,0)
	MOV	EAX,unroll(unroll([ESP+16]))
	MOV	EAX,[EAX]
	POP	ECX
	CMP	EAX,ECX
	JNE	iffalse$50
iftrue$49:
	ADD	ESP,8
	RETN
iffalse$50:
ifend$51:
	PUSH	EBP
	PUSH	tapp(trycatch$52,<s1,s2,e1,e2>)
	MOV	EBP,ESP
; 	Begin try body.
	MOV	EAX,unroll(unroll([ESP+20]))
	MOV	ECX,[EAX]
	MOV	EAX,[ESP+12]
	CMP	EAX,ECX
	JNE	iffalse$55
iftrue$54:
	MOV	EAX,unroll(unroll([ESP+20]))
	MOV	EAX,[EAX+4]
	MOV	DWORD PTR [_symbol_table],EAX
	JMP	ifend$56
iffalse$55:
	PUSH	DWORD PTR [_symbol_table]
	CALL	tapp(_List?tl,<entry,ESP 1 1 se,EBP 1,cap[],&[e1,e2]>)
	ADD	ESP,4
	MOV	[ESP+8],EAX
	JMP	whiletest$58
whilebody$57:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[cap[],&[e1,e2]],EBP: sptr (?E (sptr (?E s2 e2))::(`List?list? entry)::(`List?list? entry)::(?Sv `handle_t?::s1 s2 e1 e2)@(?E s2 e2) &[e1,e2]),ESP: sptr se@(?E (sptr (?E s2 e2))::(`List?list? entry)::(`List?list? entry)::(?Sv `handle_t?::s1 s2 e1 e2)@(?E s2 e2) &[e1,e2])}>
	MOV	EAX,[ESP+8]
	MOV	[ESP+12],EAX
	PUSH	DWORD PTR [ESP+8]
	CALL	tapp(_List?tl,<entry,ESP 1 1 se,EBP 1,cap[],&[e1,e2]>)
	ADD	ESP,4
	MOV	[ESP+8],EAX
whiletest$58:
	MOV	EAX,unroll(unroll([ESP+20]))
	MOV	ECX,[EAX]
	MOV	EAX,[ESP+8]
	CMP	EAX,ECX
	JNE	tapp(whilebody$57,<s1,s2,e1,e2>)
whileend$59:
	MOV	EAX,unroll(unroll([ESP+20]))
	PUSH	DWORD PTR [EAX+4]
	MOV	EAX,[ESP+16]
	MOV	EBX,EAX
	POP	EAX
	COERCE	unroll(unroll(EBX))
	NAMEOBJ	n$60,EBX
	CMP	EBX,0
	JE	_pop_never_null
	COERCE	forgetname(EBX)
	REMOVENAME	n$60
	MOV	[EBX+4],EAX
ifend$56:
; 	End try body.
	ADD	ESP,4
	POP	EBP
	JMP	tapp(tryend$53,<s1,s2,e1,e2>)
trycatch$52:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EAX: ?exn,ESP: sptr (?Ha (`List?list? entry)::(`List?list? entry)::(?Sv `handle_t?::s1 s2 e1 e2) s2 e1 e2)}>
	POP	EBP
	PUSH	EAX
	PUSH	string$61
	CALL	tapp(_Core?print_string,<ESP 1 6 s1,EBP 1,e1,e2>)
	MOV	DWORD PTR [ESP],subsume(<B4>,1)
	JMP	tapp(_tal_exit,<ESP 1>)

tryend$53:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (`List?list? entry)::(`List?list? entry)::(?Sv `handle_t?::s1 s2 e1 e2)@(?E s2 e2)}>
	PUSH	rollsum(<`List?list? entry>,0)
	MOV	EAX,[ESP+16]
	MOV	EBX,EAX
	POP	EAX
	COERCE	unroll(unroll(EBX))
	MOV	[EBX],EAX
	PUSH	rollsum(<`List?list? entry>,0)
	MOV	EAX,[ESP+16]
	MOV	EBX,EAX
	POP	EAX
	COERCE	unroll(unroll(EBX))
	MOV	[EBX+4],EAX
	ADD	ESP,8
	RETN


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;   
;;;    For debugging, prints out the global symbol table
;;;
_print_table:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap]. \
	    code {cap: &[e1,e2], \
	    EBP: sptr (?E s2 e2), \
	    ESP: sptr (?Sv s1 s2 e1 e2)@(?E s2 e2)}>
	PUSH	string$3
	CALL	tapp(_Core?print_string,<ESP 1 2 s1,EBP 1,e1,e2>)
	ADD	ESP,4
	PUSH	DWORD PTR [_symbol_table]
	PUSH	EBP
	PUSH	tapp(trycatch$4,<s1,s2,e1,e2>)
	MOV	EBP,ESP
; 	Begin try body.
	JMP	whiletest$7
whilebody$6:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[cap[],&[e1,e2]], \
	EBP: sptr (?E (sptr (?E s2 e2))::(`List?list? entry)::(?Sv s1 s2 e1 e2)@(?E s2 e2)\
 	&[e1,e2]),ESP: sptr se@(?E (sptr (?E s2 e2))::(`List?list? entry):: \
	(?Sv s1 s2 e1 e2)@(?E s2 e2) &[e1,e2])}>
	PUSH	DWORD PTR [ESP+8]
	CALL	tapp(_List?hd,<entry,ESP 1 1 se,EBP 1,cap[],&[e1,e2]>)
	ADD	ESP,4	
	UNPACK	ptr$1,EAX,EAX
	PUSH	DWORD PTR [EAX] 
	PUSH	DWORD PTR [ESP] 
	CALL	tapp(_Core?print_string,<ESP 1 2 se,EBP 1,cap[],&[e1,e2]>)
	MOV	[ESP],string$9
	CALL	tapp(_Core?print_string,<ESP 1 2 se,EBP 1,cap[],&[e1,e2]>)
	ADD	ESP,4           
	PUSH	DWORD PTR [ESP+12] 
	CALL	tapp(_List?tl,<entry,ESP 1 2 se,EBP 1,cap[],&[e1,e2]>)
	ADD	ESP,4	
	MOV	[ESP+12],EAX
	ADD	ESP,4
whiletest$7:
	JMP	tapp(whilebody$6,<s1,s2,e1,e2>)
whileend$8:
; 	End try body.
	ADD	ESP,4
	POP	EBP
	JMP	tapp(tryend$5,<s1,s2,e1,e2>)
trycatch$4:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2], \
EAX: ?exn,ESP: sptr (?Ha (`List?list? entry)::(?Sv s1 s2 e1 e2) s2 e1 e2)}>
	POP	EBP
	PUSH	EAX
	ADD	ESP,8
	RETN
tryend$5:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2], \
EBP: sptr (?E s2 e2),ESP: sptr (`List?list? entry)::(?Sv s1 s2 e1 e2)@(?E s2 e2)}>
	ADD	ESP,4
	RETN


;;;   
;;;    For debugging, prints out the portion of the symbol table referenced by 
;;;    a paticular handle
;;;
_print_handle_table:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap]. \
	    code {cap: &[e1,e2], \
	    EBP: sptr (?E s2 e2), \
	    ESP: sptr (?Sv `handle_t?::s1 s2 e1 e2)@(?E s2 e2)}>
	PUSH	string$10
	CALL	tapp(_Core?print_string,<ESP 1 3 s1,EBP 1,e1,e2>)
	ADD	ESP,4
	MOV	EAX,unroll(unroll([ESP+4]))
	PUSH	DWORD PTR [EAX]
	PUSH	EBP
	PUSH	tapp(trycatch$11,<s1,s2,e1,e2>)
	MOV	EBP,ESP
; 	Begin try body.
	JMP	whiletest$14
whilebody$13:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[cap[],&[e1,e2]],\
	EBP: sptr (?E (sptr (?E s2 e2))::(`List?list? entry)::(?Sv `handle_t?::s1 s2 e1 e2)@(?E s2 e2) &[e1,e2]),ESP: sptr se@(?E (sptr (?E s2 e2))::(`List?list? entry)::(?Sv `handle_t?::s1 s2 e1 e2)@(?E s2 e2) &[e1,e2])}>
	PUSH	DWORD PTR [ESP+8]
	CALL	tapp(_List?hd,<entry,ESP 1 1 se,EBP 1,cap[],&[e1,e2]>)
	ADD	ESP,4
	UNPACK	ptr$1,EAX,EAX
	PUSH	DWORD PTR [EAX]
	PUSH	DWORD PTR [ESP]
	CALL	tapp(_Core?print_string,<ESP 1 2 se,EBP 1,cap[],&[e1,e2]>)
	MOV	[ESP],string$16
	CALL	tapp(_Core?print_string,<ESP 1 2 se,EBP 1,cap[],&[e1,e2]>)
	ADD	ESP,4
	PUSH	DWORD PTR [ESP+12]
	CALL	tapp(_List?tl,<entry,ESP 1 2 se,EBP 1,cap[],&[e1,e2]>)
	ADD	ESP,4
	MOV	[ESP+12],EAX
	ADD	ESP,4
whiletest$14:
	MOV	EAX,unroll(unroll([ESP+16]))
	MOV	ECX,[EAX+4]
	MOV	EAX,[ESP+8]
	CMP	EAX,ECX
	JNE	tapp(whilebody$13,<s1,s2,e1,e2>)
whileend$15:
; 	End try body.
	ADD	ESP,4
	POP	EBP
	JMP	tapp(tryend$12,<s1,s2,e1,e2>)
trycatch$11:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EAX: ?exn,\
ESP: sptr (?Ha (`List?list? entry)::(?Sv `handle_t?::s1 s2 e1 e2) s2 e1 e2)}>
	POP	EBP
	PUSH	EAX
	ADD	ESP,8
	RETN
tryend$12:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),\
ESP: sptr (`List?list? entry)::(?Sv `handle_t?::s1 s2 e1 e2)@(?E s2 e2)}>
	ADD	ESP,4
	RETN

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;;     Typmatch and Cast
;;;

; Tail recursive version of typ_match_stack (at least for self call)
_typ_match_list:
LABELTYPE <All[va:typlist vb:typlist vc:Tm-!>T4 s1:Ts e1:Tcap e2:Tcap]. \
	code {cap: &[e1,e2],   \
	ESP: sptr (code { EAX:(`Core?Opt? (vc (interpTprod vb))), \
	           ESP:sptr s1,cap: &[e1,e2]}):: \
	(vc (interpTprod va))::(reptyplist va)::(reptyplist vb)::s1}>

	MOV	EAX,unroll([ESP+8])
	NAMEOBJ	uptr$6,EAX
	MOV	ECX,[EAX]
	CMP	ECX,0
	JE	Null_value$7
Cons_value$8:
	COERCE  rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$6
	LETROLL a1,va
	VCASE   1,beta1,a1,[EAX+4]
	MOV	EAX,unroll([ESP+16])
	NAMEOBJ	uptr$11,EAX
	MOV	ECX,[EAX]
	CMP	ECX,0
	JE	Null_value$13
Cons_value$12:
	COERCE 	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$11
	LETROLL a2,vb
	VCASE   1,beta2,a2,[EAX+4]
	MOV	EAX,[ESP]
	PUSH	DWORD PTR [EAX]
	MOV	EAX,[ESP+8]
	PUSH	DWORD PTR [EAX]
	PUSH	DWORD PTR [ESP+20]
	CALL	tapp(_typ_match,<beta1.0,beta2.0,fn a:T4.(vc (*[a^rw,interpTprod beta1.1])), \
		(^*[(reptyp beta2.0)^rw,(reptyplist beta2.1)^rw]):: \
		(^*[(reptyp beta1.0)^rw,(reptyplist beta1.1)^rw]):: \
		(code { EAX:(`Core?Opt? (vc (interpTprod vb))), ESP:sptr s1,cap: &[e1,e2]}):: \
		(vc (interpTprod va))::(reptyplist va)::(reptyplist vb)::s1,e1,e2>)
	COERCE	unroll(EAX)
	NAMEOBJ ptr$1,EAX
	CMP	DWORD PTR EAX,0
	JNE	iffalse$15
iftrue$14:
	COERCE  rec(forgetname(EAX))
	REMOVENAME ptr$1
	MOV	EAX,rollsum(<`Core?Opt? (vc (interpTprod vb))>,0)
	ADD	ESP,8
	RETN	12
iffalse$15:
	COERCE  unroll(rec(forgetname(EAX)))
	REMOVENAME ptr$1
	MOV	EAX,[EAX]
	MOV	EBX,[ESP+8]
	MOV	ECX,[ESP+4]
	MOV 	ECX,[ECX+4]
	MOV	EDX,[ESP]
	MOV	EDX,[EDX+4]
	ADD	ESP, 24
	PUSH 	EDX
	PUSH	ECX
	PUSH	EAX
	PUSH	EBX
	JMP 	tapp(_typ_match_list, <beta1.1, beta2.1, fn a:Tm. \
		(vc *[(interp beta2.0)^rw,a]),s1,e1,e2>)
Null_value$13:
	COERCE  rec(forgetname(EAX))
	REMOVENAME	uptr$11
	MOV	EAX,rollsum(<`Core?Opt? (vc (interpTprod vb))>,0)
	ADD	ESP,4
	RETN	12
Null_value$7:
	COERCE 	rec(forgetname(EAX))
	REMOVENAME	uptr$6
	LETROLL a1,va
	VCASE   0,beta1,a1,[EAX+4]
	MOV	EAX,unroll([ESP+12])
	NAMEOBJ	uptr$20,EAX
	MOV	ECX,[EAX]
	CMP	ECX,0
	JE	Null_value$21
Cons_value$22:
	COERCE  rec(forgetname(EAX))
	REMOVENAME	uptr$20
	MOV	EAX,rollsum(<`Core?Opt? (vc (interpTprod vb))>,0)
	RETN	12
Null_value$21:
	COERCE  rec(forgetname(EAX))	
	REMOVENAME	uptr$20
	LETROLL a2,vb
	VCASE   0,beta2,a2,[EAX+4]
	MALLOC	mptr$23,4
	MOV	EBX,EAX
	MOV	EAX,[ESP+4]
	MOV	[EBX],EAX
	FORGETUNIQUE	mptr$23
	MOV	EAX,rollsum(<`Core?Opt? (vc (interpTprod vb))>,    \
		roll(<^T(0)(`Core?Opt?mem (vc (interpTprod vb)))>,forgetname(EBX)))
	RETN	12

; Tail recursive version of typ_match_list (at least for self call)
; if we had kind polymorphism we could do this in one function....
_typ_match_stack:
LABELTYPE <All[va:typlist vb:typlist vc:Ts-!>T4 s1:Ts e1:Tcap e2:Tcap]. \
	code {cap: &[e1,e2],   \
	ESP: sptr (code { EAX:(`Core?Opt? (vc (interpTs vb))), \
	           ESP:sptr s1,cap: &[e1,e2]}):: \
	(vc (interpTs va))::(reptyplist va)::(reptyplist vb)::s1}>

	MOV	EAX,unroll([ESP+8])
	NAMEOBJ	uptr$6,EAX
	MOV	ECX,[EAX]
	CMP	ECX,0
	JE	SNull_value$7
SCons_value$8:
	COERCE  rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$6
	LETROLL a1,va
	VCASE   1,beta1,a1,[EAX+4]
	MOV	EAX,unroll([ESP+16])
	NAMEOBJ	uptr$11,EAX
	MOV	ECX,[EAX]
	CMP	ECX,0
	JE	SNull_value$13
SCons_value$12:
	COERCE 	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$11
	LETROLL a2,vb
	VCASE   1,beta2,a2,[EAX+4]
	MOV	EAX,[ESP]
	PUSH	DWORD PTR [EAX]
	MOV	EAX,[ESP+8]
	PUSH	DWORD PTR [EAX]
	PUSH	DWORD PTR [ESP+20]
	CALL	tapp(_typ_match,<beta1.0,beta2.0,\
		fn a:T4.(vc (a::(interpTs beta1.1))), \
		(^*[(reptyp beta2.0)^rw,(reptyplist beta2.1)^rw]):: \
		(^*[(reptyp beta1.0)^rw,(reptyplist beta1.1)^rw]):: \
		(code { EAX:(`Core?Opt? (vc (interpTs vb))), ESP:sptr s1,cap: &[e1,e2]}):: \
		(vc (interpTs va))::(reptyplist va)::(reptyplist vb)::s1,e1,e2>)
	COERCE	unroll(EAX)
	NAMEOBJ ptr$1,EAX
	CMP	DWORD PTR EAX,0
	JNE	Siffalse$15
Siftrue$14:
	COERCE  rec(forgetname(EAX))
	REMOVENAME ptr$1
	MOV	EAX,rollsum(<`Core?Opt? (vc (interpTs vb))>,0)
	ADD	ESP,8
	RETN	12
Siffalse$15:
	COERCE  unroll(rec(forgetname(EAX)))
	REMOVENAME ptr$1
	MOV	EAX,[EAX]
	MOV	EBX,[ESP+8]
	MOV	ECX,[ESP+4]
	MOV 	ECX,[ECX+4]
	MOV	EDX,[ESP]
	MOV	EDX,[EDX+4]
	ADD	ESP, 24
	PUSH 	EDX
	PUSH	ECX
	PUSH	EAX
	PUSH	EBX
	JMP 	tapp(_typ_match_stack, <beta1.1, beta2.1, fn a:Ts. \
		(vc ((interp beta2.0)::a)),s1,e1,e2>)
SNull_value$13:
	COERCE  rec(forgetname(EAX))
	REMOVENAME	uptr$11
	MOV	EAX,rollsum(<`Core?Opt? (vc (interpTs vb))>,0)
	ADD	ESP,4
	RETN	12
SNull_value$7:
	COERCE 	rec(forgetname(EAX))
	REMOVENAME	uptr$6
	LETROLL a1,va
	VCASE   0,beta1,a1,[EAX+4]
	MOV	EAX,unroll([ESP+12])
	NAMEOBJ	uptr$20,EAX
	MOV	ECX,[EAX]
	CMP	ECX,0
	JE	SNull_value$21
SCons_value$22:
	COERCE  rec(forgetname(EAX))
	REMOVENAME	uptr$20
	MOV	EAX,rollsum(<`Core?Opt? (vc (interpTs vb))>,0)
	RETN	12
SNull_value$21:
	COERCE  rec(forgetname(EAX))	
	REMOVENAME	uptr$20
	LETROLL a2,vb
	VCASE   0,beta2,a2,[EAX+4]
	MALLOC	mptr$23,4
	MOV	EBX,EAX
	MOV	EAX,[ESP+4]
	MOV	[EBX],EAX
	FORGETUNIQUE	mptr$23
	MOV	EAX,rollsum(<`Core?Opt? (vc (interpTs vb))>,    \
		roll(<^T(0)(`Core?Opt?mem (vc (interpTs vb)))>,forgetname(EBX)))
	RETN	12

_typ_match:
LABELTYPE <All[va:typ vb:typ vc:T4-!>T4 s1:Ts  e1:Tcap e2:Tcap]. \
	  code {cap: &[e1,e2], \
	  ESP: sptr \
	    (code {cap:&[e1,e2], \
	      EAX:(`Core?Opt? (vc (interp vb))), \
	      ESP:sptr s1}):: \
            (vc (interp va))::(reptyp va)::(reptyp vb)::s1}>

	MOV	EAX,unroll([ESP+8])
	NAMEOBJ	uptr$26,EAX
	MOV	ECX,[EAX]
	CMP	ECX,8
	JE	Tuple_value$30
	CMP	ECX,7
	JE 	Vfn_value$1
	CMP 	ECX,6
	JE 	Fn_value$1
	CMP 	ECX,5
	JE	Array_value$1
	CMP	ECX,4
	JE	Char_value$29
	CMP	ECX,3
	JE	String_value$28
	CMP	ECX,2
	JE	Bool_value$27
	CMP	ECX,1
	JE	Int_value$1
	CMP	ECX,0
	JE	Exn_value$1
	JMP	default$25
Int_value$1:
	COERCE	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$26
	; type refinement
	LETROLL alpha,va
	VCASE 	1,beta,alpha,[EAX+4]
	MOV	EAX,unroll([ESP+16])
	NAMEOBJ	uptr$33,EAX
	MOV	ECX,[EAX]
	CMP	ECX,1
	JE	Int_value$2
	JMP	default$32
Int_value$2:
	COERCE  rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$33
	; type refinement
	LETROLL alpha2,vb
	VCASE 	1,beta2,alpha2,[EAX+4]
	MOV	EAX,[ESP]
	PUSH	DWORD PTR [EAX]
	MOV	EAX,[ESP+8]
	MOV	EAX,[EAX]
	POP	ECX
	CMP	EAX,ECX
	JNE	iffalse$110
condtrue$112:
	MOV	EAX,[ESP]
	PUSH	DWORD PTR [EAX+4]
	MOV	EAX,[ESP+8]
	MOV	EAX,[EAX+4]
	POP	ECX
	CMP	EAX,ECX
	JNE	iffalse$110
iftrue$109:
	MALLOC	mptr$113,4
	MOV	EBX,EAX
	MOV	EAX,[ESP+12]
	MOV	[EBX],EAX
	FORGETUNIQUE	mptr$113
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>,roll(<(fn va:T4 . ^T(0)(`Core?Opt?mem va)) (vc (interp vb))>,forgetname(EBX)))
	ADD	ESP,8
	RETN	12
iffalse$110:
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>,0)
	ADD	ESP,8
	RETN	12
		

Tuple_value$30:
	COERCE	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$26
	; type refinement
	LETROLL alpha,va
	VCASE 	8,beta,alpha,[EAX+4]
	MOV	EAX,unroll([ESP+16])
	NAMEOBJ	uptr$33,EAX
	MOV	ECX,[EAX]
	CMP	ECX,8
	JE	Tuple_value$34
	JMP	default$32
Tuple_value$34:
	COERCE  rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$33
	; type refinement
	LETROLL alpha2,vb
	VCASE 	8,beta2,alpha2,[EAX+4]
	PUSH	DWORD PTR [ESP]
	PUSH	DWORD PTR [ESP+8]
	PUSH	DWORD PTR [ESP+20]
	CALL	tapp(_typ_match_list,<beta,beta2,(fn a:Tm.vc (^a)),\
	(reptyplist beta2)::(reptyplist beta):: \
	(code {cap: &[e1,e2],EAX:(`Core?Opt? (vc (interp vb))), ESP:sptr s1}):: \
	(vc (interp va))::(reptyp va)::(reptyp vb)::s1, e1,e2>)
	ADD	ESP,8
	RETN	12
default$32:
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>,0)
	ADD	ESP,4
	RETN	12

Exn_value$1:
	COERCE	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$26
;  refinement
	LETROLL alphaC1,va
	VCASE 	0,betaC1,alphaC1,[EAX+4]
	MOV	EAX,unroll([ESP+16])
	NAMEOBJ	uptr$37,EAX
	MOV	ECX,[EAX]
	CMP	ECX,0
	JE	Exn_value$2
	JMP	default$exn
Exn_value$2:
	COERCE	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$37
; refinement
	LETROLL alphaC2,vb
	VCASE 	0,betaC2,alphaC2,[EAX+4]
	MALLOC	mptr$39,4
	MOV	EBX,EAX
	MOV	EAX,[ESP+12]
	MOV	[EBX],EAX
	FORGETUNIQUE	mptr$39
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>, \
		roll(<^T(0)(`Core?Opt?mem (vc (interp vb)))>,forgetname(EBX)))
	ADD	ESP,8
	RETN 	12
default$exn:
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>,0)
	ADD	ESP,4
	RETN 	12

Vfn_value$1:
	COERCE	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$26
	; type refinement
	LETROLL alpha,va
	VCASE 	7,beta,alpha,[EAX+4]
	MOV	EAX,unroll([ESP+16])
	NAMEOBJ	uptr$33,EAX
	MOV	ECX,[EAX]
	CMP	ECX,7
	JE	Vfn_value$2
	JMP	default$vfn
Vfn_value$2:
	COERCE  rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$33
	; type refinement
	LETROLL alpha2,vb
	VCASE 	7,beta2,alpha2,[EAX+4]
	PUSH	DWORD PTR [ESP]
	PUSH	DWORD PTR [ESP+8]
	PUSH	DWORD PTR [ESP+20]
	CALL	tapp(_typ_match_stack,<beta,beta2,(fn b:Ts.vc  (vfntype b)), \
 	(reptyplist beta2)::(reptyplist beta):: \
	(code {cap:&[e1,e2],EAX:(`Core?Opt? (vc (interp vb))), ESP:sptr s1}):: \
	(vc (interp va))::(reptyp va)::(reptyp vb)::s1, e1,e2>)
	ADD	ESP,8
	RETN	12
default$vfn:
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>,0)
	ADD	ESP,4
	RETN	12

Fn_value$1:
	COERCE	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$26
	; type refinement
	LETROLL alpha,va
	VCASE 	6,beta1,alpha,[EAX+4]
	MOV	EAX,unroll([ESP+16])
	NAMEOBJ	uptr$33,EAX
	MOV	ECX,[EAX]
	CMP	ECX,6
	JE	Fn_value$2
	JMP	default$fn
Fn_value$2:
	COERCE  rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$33
	; type refinement
	LETROLL alpha2,vb
	VCASE 	6,beta2,alpha2,[EAX+4]
	MOV	EAX,[EAX+4]
	PUSH	DWORD PTR [EAX+4]    ; reptyplist beta2.1
	MOV	EAX,[ESP+8]
	PUSH	DWORD PTR [EAX+4]    ; reptyplist beta.1		
	PUSH	DWORD PTR [ESP+20]
	CALL	tapp(_typ_match_stack,<beta1.1,beta2.1, \
	(fn b:Ts. vc (fntype (interp beta1.0) b)), \
 	(^*[(reptyp beta2.0)^rw,(reptyplist beta2.1)^rw]):: \
	(^*[(reptyp beta1.0)^rw,(reptyplist beta1.1)^rw]):: \
	(code {cap: &[e1,e2],EAX:(`Core?Opt? (vc (interp vb))), ESP:sptr s1}):: \
	(vc (interp va))::(reptyp va)::(reptyp vb)::s1,e1,e2>)
	; now examine return value
	COERCE 	unroll(EAX)
	NAMEOBJ ptr$1,EAX
	CMP	DWORD PTR EAX,0
	JNE	iffalse$fn
iftrue$fn:
	COERCE  rec(forgetname(EAX))
	REMOVENAME ptr$1
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>,0)
	ADD	ESP,8
	RETN	12
iffalse$fn:
	COERCE  unroll(rec(forgetname(EAX)))
	REMOVENAME ptr$1
	; rearrange the stack to do a tail call to interp 
	MOV	EAX,[EAX]	; return value from last call
	MOV	EBX,[ESP+8]    ; return address
	MOV	ECX,[ESP+4]    ; rep of beta
	MOV	EDX,[ESP]    ; rep of beta2
	ADD	ESP,24
	PUSH 	DWORD PTR [EDX+0]
	PUSH 	DWORD PTR [ECX+0]
	PUSH 	EAX
	PUSH	EBX	
	JMP 	tapp(_typ_match, <beta1.0, beta2.0, fn a:T4. vc (fntype a (interpTs beta2.1)), \
			s1,e1,e2>) 
default$fn:
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>,0)
	ADD	ESP,4
	RETN	12

Array_value$1:
	COERCE	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$26
	; type refinement
	LETROLL alpha,va
	VCASE 	5,beta,alpha,[EAX+4]
	MOV	EAX,unroll([ESP+16])
	NAMEOBJ	uptr$33,EAX
	MOV	ECX,[EAX]
	CMP	ECX,5
	JE	Array_value$2
	JMP	default$array
Array_value$2:
	COERCE  rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$33
	; type refinement
	LETROLL alpha2,vb
	VCASE 	5,beta2,alpha2,[EAX+4]
	PUSH	DWORD PTR [ESP]
	PUSH	DWORD PTR [ESP+8]
	PUSH	DWORD PTR [ESP+20]
	CALL	tapp(_typ_match,<beta,beta2,(fn b:T4.vc  (?arr b)), \
 	(reptyp beta2)::(reptyp beta):: \
	(code {cap: &[e1,e2],EAX:(`Core?Opt? (vc (interp vb))), ESP:sptr s1}):: \
	(vc (interp va))::(reptyp va)::(reptyp vb)::s1, e1, e2>)
	ADD	ESP,8
	RETN	12
default$array:
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>,0)
	ADD	ESP,4
	RETN	12

Char_value$29:
	COERCE	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$26
;  refinement
	LETROLL alphaC1,va
	VCASE 	4,betaC1,alphaC1,[EAX+4]
	MOV	EAX,unroll([ESP+16])
	NAMEOBJ	uptr$37,EAX
	MOV	ECX,[EAX]
	CMP	ECX,4
	JE	Char_value$38
	JMP	default$36
Char_value$38:
	COERCE	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$37
; refinement
	LETROLL alphaC2,vb
	VCASE 	4,betaC2,alphaC2,[EAX+4]
	MALLOC	mptr$39,4
	MOV	EBX,EAX
	MOV	EAX,[ESP+12]
	MOV	[EBX],EAX
	FORGETUNIQUE	mptr$39
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>, \
		roll(<^T(0)(`Core?Opt?mem (vc (interp vb)))>,forgetname(EBX)))
	ADD	ESP,8
	RETN 	12
default$36:
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>,0)
	ADD	ESP,4
	RETN 	12
String_value$28:
	COERCE 	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME uptr$26
	LETROLL alphaS1,va
	VCASE 	3,betaS1,alphaS1,[EAX+4]
	MOV	EAX,unroll([ESP+16])
	NAMEOBJ	uptr$42,EAX
	MOV	ECX,[EAX]
	CMP	ECX,3
	JE	String_value$43
	JMP	default$41
String_value$43:
	COERCE 	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$42
	LETROLL alphaS2,vb
	VCASE 	3,betaS2,alphaS2,[EAX+4]	
	MALLOC	mptr$44,4
	MOV	EBX,EAX
	MOV	EAX,[ESP+12]
	MOV	[EBX],EAX
	FORGETUNIQUE	mptr$44
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>, \
		roll(<^T(0)(`Core?Opt?mem (vc (interp vb)))>,forgetname(EBX)))
	ADD	ESP,8
	RETN 	12
default$41:
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>,0)
	ADD	ESP,4
	RETN 	12
Bool_value$27:
	COERCE 	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$26
	LETROLL alphaS1,va
	VCASE 	2,betaS1,alphaS1,[EAX+4]
	MOV	EAX,unroll([ESP+16])
	NAMEOBJ	uptr$47,EAX
	MOV	ECX,[EAX]
	CMP	ECX,2
	JE	Bool_value$48
	JMP	default$46
Bool_value$48:
	COERCE  rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$47
	LETROLL alphaB2,vb
	VCASE 	2,betaB2,alphaB2,[EAX+4]	
	MALLOC	mptr$49,4
	MOV	EBX,EAX
	MOV	EAX,[ESP+12]
	MOV	[EBX],EAX
	FORGETUNIQUE	mptr$49
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>, \
		roll(<^T(0)(`Core?Opt?mem (vc (interp vb)))>,forgetname(EBX)))
	ADD	ESP,8
	RETN 	12
default$46:
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>,0)
	ADD	ESP,4
	RETN 	12
default$25:
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>,0)
	RETN 	12

;; A wrapper for typ-match 
_cast:
LABELTYPE <All[va:typ vb:typ s1:Ts s2:Ts e1:Tcap e2:Tcap]. \
	  code { cap: &[e1,e2], \
	  EBP: sptr (?E s2 e2), \
	  ESP: sptr (?S (`Core?Opt? (interp vb)) \
	             (interp va)::(reptyp va)::(reptyp vb)::s1 \
	    s2 e1 e2)@(?E s2 e2)}>
	PUSH 	EBP
	PUSH 	DWORD PTR [ESP+16]
	PUSH 	DWORD PTR [ESP+16]
	PUSH 	DWORD PTR [ESP+16]
	CALL	tapp(_typ_match,<va,vb,fn d:T4.d, 	\
		(sptr (?E s2 e2)):: \
		(?S (`Core?Opt? (interp vb)) (interp va)::(reptyp va)::(reptyp vb)::s1 s2 e1 e2) \
		@(?E s2 e2), e1,e2>)
	POP	EBP
	RETN



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;      DATA   SEGMENT 
;;;;;;;;;


	DATA

;; inittype -- these monster byte represent that hairy abbrev at the beginning.
string$30:
COERCE 	pack(<1273>, ?, <Exist[i:Sint].^*[S(i)^rw,(Rep(inittype, i))^r]>)
	DD	1273
	DTYPEREP 	\
49,115,49,0,115,50,0,101,49,0,101,50,0,118,97,0,116,121,112,36,49,0,116,121,112,108,105,115,116,36,48,0,63,115,122,0,114,101,112,116,121,112,0,97,0,117,110,114,111,108,95,116,121,112,36,49,49,0,116,121,112,36,49,48,0,116,121,112,108,105,115,116,36,56,0,117,110,114,111,108,95,116,121,112,108,105,115,116,36,57,0,98,0,98,36,49,50,0,98,36,49,51,0,114,101,112,116,121,112,108,105,115,116,0,99,36,48,0,105,110,116,101,114,112,36,55,0,116,121,112,36,54,0,116,121,112,108,105,115,116,36,51,0,105,110,116,101,114,112,84,115,36,53,0,105,110,116,101,114,112,84,112,114,111,100,36,52,0,57,83,67,42,0,43,5,5,0,43,5,5,5,0,42,7,9,0,86,11,86,13,42,13,15,0,43,5,11,5,5,5,13,17,15,15,0,43,5,17,0,85,11,5,11,19,13,21,73,52,62,23,27,86,23,86,25,42,31,33,0,43,5,11,5,5,5,31,35,33,33,0,43,5,35,0,85,13,5,11,19,13,21,62,41,27,77,86,41,86,43,42,47,49,0,43,5,11,5,5,5,47,51,49,49,0,43,5,51,0,186,1,84,86,15,83,3,70,5,82,49,70,9,66,118,3,11,42,5,7,13,33,1,1,15,0,69,15,25,1,17,73,0,83,21,70,23,82,86,19,80,21,5,23,19,37,21,37,27,25,19,39,27,39,27,97,29,27,52,48,27,59,31,29,19,33,35,35,35,35,35,35,35,35,70,37,66,42,5,25,39,73,1,83,43,70,45,82,86,29,35,1,49,59,51,31,5,21,43,83,53,70,55,66,35,3,49,73,2,59,59,33,7,21,43,61,83,63,70,65,66,42,5,57,67,33,1,1,69,0,59,31,29,19,35,71,35,35,35,35,35,35,35,70,73,66,42,5,47,75,83,61,70,79,82,59,31,29,19,35,35,33,35,35,35,35,35,35,70,83,66,42,5,81,85,73,3,83,89,70,91,82,59,31,29,19,35,35,35,33,35,35,35,35,35,70,95,66,42,5,93,97,73,4,83,101,70,103,82,59,31,29,19,35,35,35,35,33,35,35,35,35,70,107,66,42,5,105,109,73,5,83,113,70,115,82,86,17,97,119,49,59,31,29,19,35,35,35,35,35,121,35,35,35,70,123,66,42,5,117,125,73,6,83,129,70,131,82,97,119,51,70,135,66,86,35,97,139,59,70,141,66,42,5,137,143,33,1,1,145,0,59,31,29,19,35,35,35,35,35,35,147,35,35,70,149,66,42,5,133,151,73,7,83,155,70,157,82,97,139,49,59,31,29,19,35,35,35,35,35,35,35,161,35,70,163,66,42,5,159,165,73,8,83,169,70,171,82,59,31,29,19,35,35,35,35,35,35,35,35,161,70,175,66,42,5,173,177,43,19,41,77,87,99,111,127,153,167,179,33,1,1,181,0,92,19,23,183,80,27,5,23,19,37,21,37,27,25,19,39,27,39,27,97,187,27,59,189,29,5,33,35,70,191,66,42,5,25,193,59,189,29,5,35,147,70,197,66,42,5,47,199,43,5,195,201,33,1,1,203,0,92,19,41,205,117,5,17,29,185,35,43,207,35,1,209,86,9,97,211,213,86,1,86,3,115,219,74,4,42,3,223,86,37,33,1,1,225,1,227,66,70,229,82,42,5,231,227,33,1,1,233,0,69,37,45,1,235,86,7,109,1,221,65,237,0,239,67,241,58,243,219,64,217,245,58,215,247,58,19,249,115,251,115,245,33,5,0,1,0,0,86,39,97,2,1,49,70,4,1,66,118,3,6,1,42,5,7,8,1,33,1,1,10,1,0,69,15,25,1,12,1,86,45,97,16,1,59,64,18,1,247,115,20,1,97,2,1,51,86,5,106,5,26,1,239,109,0,22,1,255,65,24,1,0,28,1,67,30,1,58,32,1,20,1,115,34,1,109,0,36,1,255,0,28,1,67,38,1,65,7,3,40,1,65,5,3,42,1,65,3,1,44,1,65,1,1,46,1,97,16,1,49,64,50,1,247,115,52,1,109,0,54,1,255,0,28,1,67,56,1,58,58,1,52,1,115,60,1,109,0,62,1,255,0,28,1,67,64,1,65,7,3,66,1,65,5,3,68,1,65,3,1,70,1,65,1,1,72,1,86,47,97,76,1,49,33,1,1,78,1,0,59,27,29,19,237,33,0,1,19,33,14,1,48,1,74,1,80,1,101,58,24,1,18,1,59,27,29,5,84,1,86,1,42,1,70,24,1,66,97,76,1,59,42,5,92,1,94,1,59,27,29,5,90,1,96,1,80,39,7,41,19,53,39,27,82,1,43,19,55,45,1,88,1,43,19,55,47,45,98,1,97,100,1,213,109,0,253,255,65,102,1,0,28,1,67,104,1,58,106,1,251,115,108,1,109,0,110,1,255,0,28,1,67,112,1,65,7,3,114,1,65,5,3,116,1,65,3,1,118,1,65,1,1,120,1,65,9,23,122,1,58,102,1,247,58,215,126,1,58,19,128,1,115,130,1,109,0,132,1,255,0,28,1,67,134,1,58,136,1,130,1,115,138,1,109,0,140,1,255,0,28,1,67,142,1,65,7,3,144,1,65,5,3,146,1,65,3,1,148,1,65,1,1,150,1,65,9,23,152,1,58,154,1,247,58,124,1,156,1,115,158,1,109,0,160,1,255,0,28,1,67,162,1,58,164,1,158,1,115,166,1,109,0,168,1,255,0,28,1,67,170,1,65,7,3,172,1,65,5,3,174,1,65,3,1,176,1,65,1,1,178,1,70,180,1,66,42,3,182,1,1,184,1


;; rb 
string$22:
COERCE	pack(<2>,array(4,0,<B1^rw>,?),<?str>)
	DD	2
	TAL_STRUCT
	DB	114,98
string$23:
COERCE	pack(<2>,array(4,0,<B1^rw>,?),<?str>)
	DD	2
	TAL_STRUCT
	DB	114,98
;; .to
string$21:
COERCE	pack(<3>,array(4,0,<B1^rw>,?),<?str>)
	DD	3
	TAL_STRUCT
	DB	46,116,111
;; .o
string$20:
COERCE	pack(<2>,array(4,0,<B1^rw>,?),<?str>)
	DD	2
	TAL_STRUCT
	DB	46,111

;; global symbol table
_symbol_table:
LABELTYPE <^*[(`List?list? entry)^rw]>
	DD	rollsum(<`List?list? entry>,0)

;; exceptions that may be raised 
FailsTypeCheck?exn:
LABELTYPE <?exnname B4^r>
	DD	?
SymbolNotFound?exn:
LABELTYPE <?exnname ?str^r>
	DD	?
WrongType?exn:
LABELTYPE <?exnname ?str^r>
	DD	?

;; Strings for print_table
; symbol table contains:
string$3:
COERCE	pack(<22>,array(4,0,<B1^rw>,?),<?str>)
	DD	22
	TAL_STRUCT
	DB	83,121,109,98,111,108,32,116,97,98,108,101,32,99,111,110,116,97,105,110,115,10
; newline
string$9:
COERCE	pack(<1>,array(4,0,<B1^rw>,?),<?str>)
	DD	1
	TAL_STRUCT
	DB	10
string$16:
COERCE	pack(<1>,array(4,0,<B1^rw>,?),<?str>)
	DD	1
	TAL_STRUCT
	DB	10

string$10:
COERCE	pack(<30>,array(4,0,<B1^rw>,?),<?str>)
	DD	30
	TAL_STRUCT
	DB	72,97,110,100,108,101,32,115,121,109,98,111,108,32,116,97,98,108,101,32,99,111,110,116,97,105,110,115,58,10


;; "Compiler bug detected in print_string"
string$61:
COERCE	pack(<37>,array(4,0,<B1^rw>,?),<?str>)
	DD	37
	TAL_STRUCT
	DB	67,111,109,112,105,108,101,114,32,98,117,103,32,100,101,116,101,99,116,101,100,32,105,110,32,112,114,105,110,116,95,115
	DB	116,114,105,110,103


	_end_TAL
	END
