; TAL IMPLEMENTATION bar
; This file was generated by TALC
	INCLUDE	TAL.INC
	_begin_TAL


	TAL_IMPORT	pop_runtime.tali
	TAL_IMPORT 	loader.tali
	TAL_IMPORT	dlpop_i.tali

	TAL_EXPORT	dlpop_e.tali

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;;     LX version of popcorn types
;;;;
;;;;

kind <var = Sint>
kind <unit = *[] >
kind <bool = +[ unit,     \ ; false
		unit ] >    ; true
kind <size = +[ unit,     \ ; B1
	        unit,     \ ; B2
	        unit ]>     ; B4

reckind <typlist = +[ unit, *[typ, typlist]]>
andkind <typ = +[ unit,      \ ; exn 
	       *[bool,size], \ ; int 
	       unit,      \ ; bool
               unit,      \ ; string 
	       unit,      \ ; char
	       typ,       \ ; array (can't specify size)
	       *[typ,typlist], \ ; mono-morphic functions (returning a value)
	       typlist, \   ; mono-morphic functions (returning void)
	       typlist \   ; tuples
 ]>   
              ; need structs, unions
kind <utyplist = +[ unit, *[typ, typlist]]>
kind <utyp =  +[ unit,      \ ; exn 
	       *[bool,size], \ ; int 
	       unit,      \ ; bool
               unit,      \ ; string 
	       unit,      \ ; char
	       typ,       \ ; array (can't specify size)
               *[typ,typlist], \ ; mono functions
	       typlist, \   ;  mono-morphic functions (returning void)
	       typlist]>    ; tuples

reckind <Tlist  = +[unit, *[T, Tlist]]>
kind    <uTlist = +[unit, *[T, Tlist]]>

; Abbreviations for the types of popcorn functions
type < fntype = fn ret:T4 args:Ts. \
 (All[s1:Ts s2:Ts e1:Tcap e2:Tcap]. code {cap: &[e1,e2], EBP: sptr (?E s2 e2), ESP: sptr  \
   (?S ret (args@s1) s2 e1 e2)@(?E s2 e2)})>
type < vfntype = fn args:Ts. \
 (All[s1:Ts s2:Ts e1:Tcap e2:Tcap]. code {cap: &[e1,e2], EBP: sptr (?E s2 e2), ESP: sptr  \
   (?Sv (args@s1) s2 e1 e2)@(?E s2 e2)})>

type <crexn = roll [typ] (inj 0 [] [utyp])>
type <crint = fn a:bool b:size. roll [typ] (inj 1 [a,b] [utyp])>
type <crbool = roll [typ] (inj 2 [] [utyp])>
type <crstring = roll [typ] (inj 3 [] [utyp])>
type <crchar = roll [typ] (inj 4 [] [utyp])>
type <crarray = fn a:typ. roll [typ] (inj 5 a [utyp])>
type <crfn = fn a:typ b:typlist. roll [typ] (inj 6 [a,b] [utyp])>
type <crvfn = fn a:typlist. roll [typ] (inj 7 a [utyp])>
type <crtuple = fn a:typlist . roll [typ] (inj 8 a [utyp])>

type <crnull = roll [typlist] (inj 0 [] [utyplist])>
type <crcons = fn a: typ b:typlist. roll [typlist] (inj 1 [a,b] [utyplist])>

type <crfalse = inj 0 [] [bool]>
type <crtrue = inj 1 [] [bool]>

type <crb1 = inj 0 [] [size]>
type <crb2 = inj 1 [] [size]>
type <crb4 = inj 2 [] [size]>

; Produce the TAL type from the popcorn type
primrec <interpTprod : typlist -!> Tm = fn a:+[ *[], *[typ, typlist]].  \
	case (a) b [ *[], \
	             *[ (interp (b.0))^rw, interpTprod (b.1)]]>
andprim <interpTs : typlist -!> Ts = fn a:+[ *[], *[typ, typlist]].  \
	case (a) b [ se, \
	             (interp b.0)::(interpTs (b.1))]>
andprim <interp : typ -!> T4 = fn a:+[ unit,      \ ; Void 
	       *[bool,size], \ ; int 
	       unit,      \ ; bool
               unit,      \ ; string 
	       unit,      \ ; char
	       typ,       \ ; array (can't specify size)
               *[typ,typlist], \ ; mono functions
	       typlist,   \
	       typlist] . \
	(case (a) b [ ?exn,                \  ; exception
	   	      B4,                     \  ; int 	
	              ^T[0,1], 		      \  ; bool
		      ?str, 		      \  ; str
		      B4, 	 	      \  ; char 
		      ?arr (interp b),         \  ; array
		      fntype (interp (b.0)) (interpTs (b.1)), \
		      vfntype (interpTs b), \
                      ^(interpTprod b)])>

primrec < unrol_typlist : typlist -!> +[unit, *[typ, typlist]] =  \
	fn a: +[unit, *[typ, typlist]] . a >
andprim <unrol_typ : typ -!>+[ unit,      \ ; exception
	       *[bool,size], \ ; int 
	       unit,      \ ; bool
               unit,      \ ; string 
	       unit,      \ ; char
	       typ,       \ ; array (can't specify size)
               *[typ,typlist], \ ; mono functions
	       typlist,        \ ; mono void returning functions
	       typlist]  = fn a:+[ unit,      \ ; exception
	       *[bool,size], \ ; int 
	       unit,      \ ; bool
               unit,      \ ; string 
	       unit,      \ ; char
	       typ,       \ ; array (can't specify size)
               *[typ,typlist], \ ; mono functions
	       typlist,     \
	       typlist] . a>
;
; Create the type of the representation of it. 
type    < repbool = fn a:bool . S (case (a) b [0, 1])>
type    < repsize = fn a:size . S (case (a) b [0, 1, 2])>
type    < rep = rec (   \
	   rep_typ : typ -!> T4. fn a: typ. \
	     ^+[*[S(0)^r, (case (unrol_typ a) b			       \
		     [ B4, void[T4], void[T4], void[T4], void[T4],        \
	               void[T4], void[T4], void[T4], void[T4]])^rw],   \
	        *[S(1)^r, (case (unrol_typ a) b			       \
		     [ void[T4], ^*[(repbool (b.0))^rw, (repsize (b.1))^rw], \
					   void[T4], void[T4], void[T4],        \
	               void[T4], void[T4], void[T4], void[T4]])^rw],   \
	        *[S(2)^r, (case (unrol_typ a) b			       \
		     [ void[T4], void[T4], B4, void[T4], void[T4],        \
	               void[T4], void[T4], void[T4], void[T4]])^rw],   \
	        *[S(3)^r, (case (unrol_typ a) b			       \
		     [ void[T4], void[T4], void[T4], B4, void[T4],       \
	              void[T4], void[T4], void[T4], void[T4]])^rw],   \
	        *[S(4)^r, (case (unrol_typ a) b			       \
		     [ void[T4], void[T4], void[T4], void[T4],         \
	               B4,void[T4], void[T4], void[T4], void[T4]])^rw],   \
	        *[S(5)^r, (case (unrol_typ a) b			       \
		     [ void[T4], void[T4], void[T4], void[T4],         \
	               void[T4], rep_typ b, void[T4],  void[T4], void[T4]])^rw],   \
	        *[S(6)^r, (case (unrol_typ a) b			   \    
		     [ void[T4], void[T4], void[T4], void[T4],     \    
	               void[T4], void[T4], ^*[(rep_typ (b.0))^rw,  \ 
			(rep_typlist (b.1))^rw],  void[T4], void[T4]])^rw],   \ 
	        *[S(7)^r, (case (unrol_typ a) b			       \
		     [ void[T4], void[T4], void[T4], void[T4],         \
	               void[T4], void[T4], void[T4], rep_typlist b, void[T4] ])^rw],   \
	        *[S(8)^r, (case (unrol_typ a) b			       \
		     [ void[T4], void[T4], void[T4], void[T4],         \
	               void[T4], void[T4], void[T4], void[T4], rep_typlist b])^rw]],  \
	   rep_typlist : typlist -!> T4 . fn a: typlist. \
	      ^+[*[S(0)^r, (case (unrol_typlist a) b \
		     [ B4, void[T4] ])^rw],          \
		 *[S(1)^r, (case (unrol_typlist a) b \
		     [ void[T4], ^*[(rep_typ (b.0))^rw, \
		                    (rep_typlist (b.1))^rw]])^rw]])>
type <reptyp = rep.0>
type <reptyplist = rep.1>

;; an abbreviation for the type of the entries in the symbol table.
TYPE 	<entry = Exist[b:typ].^*[?str^rw,(reptyp b)^rw,(interp b)^rw]>
;; an abbreviation for the type of the function init. In R-popcorn it should be:
;; void init (a lookup_symbol<a>(string, R(a)), void add_symbol<a>(string, R(a), a));
TYPE 	<initfntype = (All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),\
	ESP: sptr (?Sv (All[va:typ s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],		\
	EBP: sptr (?E s2 e2),ESP: sptr (?S (interp va) ?str::(reptyp va)::s1 s2 e1 e2)@(?E s2 e2)})::	\
	(All[va:typ s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),	\
	ESP: sptr (?Sv ?str::(reptyp va)::(interp va)::s1 s2 e1 e2)@(?E s2 e2)})::s1 \
	s2 e1 e2)@(?E s2 e2)})>
TYPE 	<inittype = *[initfntype^rw]>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;   
;;;;   Type labels -- implement the type handle
;;;;
	TYPE	<bogus_option$1 :T4 = ^T[0]>
	TYPE	<handle_t? :T4 = ^`handle_t?mem>
	TYPE	<handle_t?mem :Tm 8 = *[(`List?list? entry)^rw,(`List?list? entry)^rw]>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;;    CODE SEGMENT
;;;;

	CODE
;;;;
;;;;   Helper functions: 
;;;;

;;;;   passed to init functions to find symbols in the global table
;;;;   I put dlpop? in its name so it could be exported instead of dlsym, and not conflict.
_dlpop?lookup_symbol:
LABELTYPE <All[va:typ s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2), \
ESP: sptr (?S (interp va) ?str::(reptyp va)::s1 s2 e1 e2)@(?E s2 e2)}>
	PUSH	DWORD PTR [ESP+8]
	PUSH	DWORD PTR [ESP+8]
	PUSH	rollsum(<`List?list? entry>,0)
	PUSH	DWORD PTR [_symbol_table]
	CALL	tapp(_find,<va,ESP 4 7 s1,EBP 1,e1,e2>)
	ADD	ESP,16
	RETN

;;;;  passed to init functions to add symbols at the beginning of the symbol table
_add_symbol:
LABELTYPE <All[va:typ s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2), \
ESP: sptr (?Sv ?str::(reptyp va)::(interp va)::s1 s2 e1 e2)@(?E s2 e2)}>
	PUSH	DWORD PTR [_symbol_table]
	MALLOC	mptr$35,12
	MOV	EBX,EAX
	MOV	EAX,[ESP+8]
	MOV	[EBX],EAX
	MOV	EAX,[ESP+12]
	MOV	[EBX+4],EAX
	MOV	EAX,[ESP+16]
	MOV	[EBX+8],EAX
	FORGETUNIQUE	mptr$35
	COERCE  pack(<va>,forgetname(EBX),<entry>)
	PUSH	EBX
	CALL	tapp(_List?cons,<entry,ESP 2 6 s1,EBP 1,e1,e2>)
	ADD	ESP,8
	MOV	DWORD PTR [_symbol_table],EAX
	RETN

;;;;   Helper function for finding symbols. Takes a pointer to the start of the list, 
;;;;   and a pointer to the end, and looks between them.
_find:
LABELTYPE <All[va:typ s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2), \
ESP: sptr (?S (interp va) (`List?list? entry):: \
(`List?list? entry)::?str::(reptyp va)::s1 s2 e1 e2)@(?E s2 e2)}>
	PUSH	DWORD PTR [ESP+4]
	PUSH	rollsum(<`Core?Opt? (interp va)>,0)
	JMP	whiletest$4
whilebody$3:
LABELTYPE <All[va:typ s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap:&[e1,e2],EBP: sptr (?E s2 e2), \
ESP: sptr (`Core?Opt? (interp va))::(`List?list? entry):: \
(?S (interp va) (`List?list? entry)::(`List?list? entry)::\
?str::(reptyp va)::s1 s2 e1 e2)@(?E s2 e2)}>
	PUSH	subsume(<B4>,0)
	PUSH	DWORD PTR [ESP+24]
	MOV	EAX,unroll(unroll([ESP+12]))
	NAMEOBJ	n$9,EAX
	CMP	EAX,0
	JE	_pop_never_null
	COERCE	forgetname(EAX)
	REMOVENAME	n$9
	MOV	EAX,[EAX]
	unpack	vb,EAX,EAX
	PUSH	DWORD PTR [EAX]
	CALL	tapp(_Core?strcmp,<ESP 2 10 s1,EBP 1,e1,e2>)
	ADD	ESP,8
	POP	ECX
	CMP	EAX,ECX
	JNE	iffalse$7
iftrue$6:
	MOV	EAX,unroll(unroll([ESP+4]))
	NAMEOBJ	n$10,EAX
	CMP	EAX,0
	JE	_pop_never_null
	COERCE	forgetname(EAX)
	REMOVENAME	n$10
	MOV	EAX,[EAX]
	unpack	vb,EAX,EAX
	PUSH	DWORD PTR [ESP+24]
	PUSH	DWORD PTR [EAX+4]
	PUSH	DWORD PTR [EAX+8]

	CALL	tapp(_cast,<vb,va,ESP 3 10 s1,EBP 1,e1,e2>)
	ADD	ESP,12
	MOV	[ESP],EAX
	MOV	EAX,[ESP]
	COERCE 	unroll(unroll(EAX))
	NAMEOBJ	n, EAX
	CMP	EAX,0
	JNE	iffalse$13
iftrue$12:
	PUSH	DWORD PTR [ESP+20]
	MALLOC	mptr$15,8
	POP	EBX
	MOV	[EAX+4],EBX
	MOV	EBX,WrongType?exn
	MOV	[EAX],EBX
	FORGETUNIQUE	mptr$15
	COERCE	pack(<?str^r>,forgetname(EAX),<?exn>)
	MOV	ESP,EBP
	POP	EBX
	JMP	EBX
iffalse$13:
	MOV	EAX,forgetname(EAX)
	MOV	EAX,[EAX]	
	ADD	ESP,8
	RETN
iffalse$7:
	MOV	EAX,unroll(unroll([ESP+4]))
	NAMEOBJ	n$17,EAX
	CMP	EAX,0
	JE	_pop_never_null
	COERCE	forgetname(EAX)
	REMOVENAME	n$17
	MOV	EAX,[EAX+4]
	MOV	[ESP+4],EAX
ifend$8:
whiletest$4:
	MOV	ECX,[ESP+16]
	MOV	EAX,[ESP+4]
	CMP	EAX,ECX
	JNE	tapp(whilebody$3,<va,s1,s2,e1,e2>)
whileend$5:
	PUSH	DWORD PTR [ESP+20]
	MALLOC	mptr$18,8
	POP	EBX
	MOV	[EAX+4],EBX
	MOV	EBX,SymbolNotFound?exn
	MOV	[EAX],EBX
	FORGETUNIQUE	mptr$18
	COERCE	pack(<?str^r>,forgetname(EAX),<?exn>)
	MOV	ESP,EBP
	POP	EBX
	JMP	EBX

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;;		Exported functions
;;;;

_dlinit:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2), \
	ESP: sptr (?Sv (initfntype)::s1 s2 e1 e2)@(?E s2 e2)}>
	PUSH	_add_symbol
	PUSH	_dlpop?lookup_symbol
	MOV	EAX,[ESP+12]
	CALL	tapp(EAX,<ESP 2 4 s1,EBP 1,e1,e2>)
	ADD	ESP,8
	RETN


_dlsym:
LABELTYPE <All[va:typ s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),\
	ESP: sptr (?S (interp va) `handle_t?::?str::(reptyp va)::s1 s2 e1 e2)@(?E s2 e2)}>
	PUSH	DWORD PTR [ESP+12]
	PUSH	DWORD PTR [ESP+12]
	MOV	EAX,unroll(unroll([ESP+12]))
	PUSH	DWORD PTR [EAX+4]
	MOV	EAX,unroll(unroll([ESP+16]))
	PUSH	DWORD PTR [EAX]
	CALL	tapp(_find,<va,ESP 4 8 s1,EBP 1,e1,e2>)
	ADD	ESP,12
	ADD	ESP,4
	RETN
_dlopen:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S `handle_t? ?str::s1 s2 e1 e2)@(?E s2 e2)}>
	PUSH	subsume(<B4>,0)
	MALLOC	mptr$19,8
	MOV	EBX,EAX
	MOV	DWORD PTR [EBX],rollsum(<`List?list? entry>,0)
	MOV	DWORD PTR [EBX+4],rollsum(<`List?list? entry>,0)
	FORGETUNIQUE	mptr$19
	PUSH	roll(<`handle_t?>,roll(<^`handle_t?mem>,forgetname(EBX)))

	PUSH	string$20
	PUSH	DWORD PTR [ESP+16]
	CALL	tapp(_Core?strconcat,<ESP 2 6 s1,EBP 1,e1,e2>)
	ADD	ESP,4
	MOV	[ESP],EAX
	PUSH	string$21
	PUSH	DWORD PTR [ESP+20]
	CALL	tapp(_Core?strconcat,<ESP 2 7 s1,EBP 1,e1,e2>)
	ADD	ESP,4
	MOV	[ESP],EAX
	PUSH	string$22
	PUSH	DWORD PTR [ESP+8]
	CALL	tapp(_Core?file_open,<ESP 2 8 s1,EBP 1,e1,e2>)
	ADD	ESP,4
	MOV	[ESP],EAX
	PUSH	string$23
	PUSH	DWORD PTR [ESP+8]
	CALL	tapp(_Core?file_open,<ESP 2 9 s1,EBP 1,e1,e2>)
	ADD	ESP,4
	MOV	[ESP],EAX
	PUSH	DWORD PTR [ESP+12]
	CALL	tapp(_Core?file_length,<ESP 1 9 s1,EBP 1,e1,e2>)
	MOV	[ESP],EAX
	PUSH	DWORD PTR [ESP]
	CALL	tapp(_Core?new_string,<ESP 1 10 s1,EBP 1,e1,e2>)
	MOV	[ESP],EAX
	PUSH	DWORD PTR [ESP+16]
	CALL	tapp(_Core?file_length,<ESP 1 11 s1,EBP 1,e1,e2>)
	MOV	[ESP],EAX
	PUSH	DWORD PTR [ESP]
	CALL	tapp(_Core?new_string,<ESP 1 12 s1,EBP 1,e1,e2>)
	MOV	[ESP],EAX
	PUSH	DWORD PTR [ESP+12]
	PUSH	subsume(<B4>,0)
	PUSH	DWORD PTR [ESP+16]
	PUSH	DWORD PTR [ESP+32]
	CALL	tapp(_f_string_read,<ESP 4 16 s1,EBP 1,e1,e2>)
	ADD	ESP,16
	PUSH	DWORD PTR [ESP+20]
	CALL	tapp(_Core?file_close,<ESP 1 13 s1,EBP 1,e1,e2>)
	ADD	ESP,4
	PUSH	DWORD PTR [ESP+4]
	PUSH	subsume(<B4>,0)
	PUSH	DWORD PTR [ESP+8]
	PUSH	DWORD PTR [ESP+28]
	CALL	tapp(_f_string_read,<ESP 4 16 s1,EBP 1,e1,e2>)
	ADD	ESP,16
	PUSH	DWORD PTR [ESP+16]
	CALL	tapp(_Core?file_close,<ESP 1 13 s1,EBP 1,e1,e2>)
	ADD	ESP,4
	PUSH	DWORD PTR [_symbol_table]
	MOV	EAX,[ESP+36]
	MOV	EBX,EAX
	POP	EAX
	COERCE	unroll(unroll(EBX))
	MOV	[EBX+4],EAX
	PUSH	EBP
	PUSH	string$30
	PUSH	DWORD PTR [ESP+8]
	PUSH	DWORD PTR [ESP+20]
	CALL	tapp(_tal_load,<inittype,ESP 3 16 (s1@(code {cap: e2,EAX: ?exn,ESP: sptr s2})::s2),e1,e2>)
	ADD	ESP,12
	POP	EBP
	NAMEOBJ	p, EAX
	CMP	EAX,0
	JNE	iffalse$32
iftrue$31:
	PUSH	0
	MALLOC	mptr$34,8
	POP	EBX
	MOV	[EAX+4],EBX
	MOV	EBX,FailsTypeCheck?exn
	MOV	[EAX],EBX
	FORGETUNIQUE	mptr$34
	COERCE	pack(<B4^r>,forgetname(EAX),<?exn>)
	MOV	ESP,EBP
	POP	EBX
	JMP	EBX
iffalse$32:
ifend$33:
	COERCE	 forgetname(EAX)
	MOV	EAX,[EAX]
	PUSH	_add_symbol
	PUSH	_dlpop?lookup_symbol
	CALL	tapp(EAX,<ESP 2 14 s1,EBP 1,e1,e2>)
	ADD	ESP,8
	MOV	EAX,[ESP+32]
	COERCE	unroll(unroll(EAX))
	MOV	EBX,[_symbol_table]
	MOV	[EAX],EBX
	MOV	EAX,[ESP+32]
	ADD	ESP,40
	RETN
;;;;;
;;;;; _dlclose 
;;;;; 

_dlclose:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?Sv `handle_t?::s1 s2 e1 e2)@(?E s2 e2)}>
	PUSH	DWORD PTR [_symbol_table]
	PUSH	rollsum(<`List?list? entry>,0)
	PUSH	rollsum(<`List?list? entry>,0)
	MOV	EAX,unroll(unroll([ESP+16]))
	MOV	EAX,[EAX]
	POP	ECX
	CMP	EAX,ECX
	JNE	iffalse$50
iftrue$49:
	ADD	ESP,8
	RETN
iffalse$50:
ifend$51:
	PUSH	EBP
	PUSH	tapp(trycatch$52,<s1,s2,e1,e2>)
	MOV	EBP,ESP
; 	Begin try body.
	MOV	EAX,unroll(unroll([ESP+20]))
	MOV	ECX,[EAX]
	MOV	EAX,[ESP+12]
	CMP	EAX,ECX
	JNE	iffalse$55
iftrue$54:
	MOV	EAX,unroll(unroll([ESP+20]))
	MOV	EAX,[EAX+4]
	MOV	DWORD PTR [_symbol_table],EAX
	JMP	ifend$56
iffalse$55:
	PUSH	DWORD PTR [_symbol_table]
	CALL	tapp(_List?tl,<entry,ESP 1 1 se,EBP 1,cap[],&[e1,e2]>)
	ADD	ESP,4
	MOV	[ESP+8],EAX
	JMP	whiletest$58
whilebody$57:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[cap[],&[e1,e2]],EBP: sptr (?E (sptr (?E s2 e2))::(`List?list? entry)::(`List?list? entry)::(?Sv `handle_t?::s1 s2 e1 e2)@(?E s2 e2) &[e1,e2]),ESP: sptr se@(?E (sptr (?E s2 e2))::(`List?list? entry)::(`List?list? entry)::(?Sv `handle_t?::s1 s2 e1 e2)@(?E s2 e2) &[e1,e2])}>
	MOV	EAX,[ESP+8]
	MOV	[ESP+12],EAX
	PUSH	DWORD PTR [ESP+8]
	CALL	tapp(_List?tl,<entry,ESP 1 1 se,EBP 1,cap[],&[e1,e2]>)
	ADD	ESP,4
	MOV	[ESP+8],EAX
whiletest$58:
	MOV	EAX,unroll(unroll([ESP+20]))
	MOV	ECX,[EAX]
	MOV	EAX,[ESP+8]
	CMP	EAX,ECX
	JNE	tapp(whilebody$57,<s1,s2,e1,e2>)
whileend$59:
	MOV	EAX,unroll(unroll([ESP+20]))
	PUSH	DWORD PTR [EAX+4]
	MOV	EAX,[ESP+16]
	MOV	EBX,EAX
	POP	EAX
	COERCE	unroll(unroll(EBX))
	NAMEOBJ	n$60,EBX
	CMP	EBX,0
	JE	_pop_never_null
	COERCE	forgetname(EBX)
	REMOVENAME	n$60
	MOV	[EBX+4],EAX
ifend$56:
; 	End try body.
	ADD	ESP,4
	POP	EBP
	JMP	tapp(tryend$53,<s1,s2,e1,e2>)
trycatch$52:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EAX: ?exn,ESP: sptr (?Ha (`List?list? entry)::(`List?list? entry)::(?Sv `handle_t?::s1 s2 e1 e2) s2 e1 e2)}>
	POP	EBP
	PUSH	EAX
	PUSH	string$61
	CALL	tapp(_Core?print_string,<ESP 1 6 s1,EBP 1,e1,e2>)
	MOV	DWORD PTR [ESP],subsume(<B4>,1)
	JMP	tapp(_tal_exit,<ESP 1>)

tryend$53:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (`List?list? entry)::(`List?list? entry)::(?Sv `handle_t?::s1 s2 e1 e2)@(?E s2 e2)}>
	PUSH	rollsum(<`List?list? entry>,0)
	MOV	EAX,[ESP+16]
	MOV	EBX,EAX
	POP	EAX
	COERCE	unroll(unroll(EBX))
	MOV	[EBX],EAX
	PUSH	rollsum(<`List?list? entry>,0)
	MOV	EAX,[ESP+16]
	MOV	EBX,EAX
	POP	EAX
	COERCE	unroll(unroll(EBX))
	MOV	[EBX+4],EAX
	ADD	ESP,8
	RETN


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;   
;;;    For debugging, prints out the global symbol table
;;;
_print_table:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?Sv s1 s2 e1 e2)@(?E s2 e2)}>
	PUSH	string$3
	CALL	tapp(_Core?print_string,<ESP 1 2 s1,EBP 1,e1,e2>)
	ADD	ESP,4
	PUSH	DWORD PTR [_symbol_table]
	PUSH	EBP
	PUSH	tapp(trycatch$4,<s1,s2,e1,e2>)
	MOV	EBP,ESP
; 	Begin try body.
	JMP	whiletest$7
whilebody$6:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[cap[],&[e1,e2]], \
	EBP: sptr (?E (sptr (?E s2 e2))::(`List?list? entry)::(?Sv s1 s2 e1 e2)@(?E s2 e2)\
 	&[e1,e2]),ESP: sptr se@(?E (sptr (?E s2 e2))::(`List?list? entry):: \
	(?Sv s1 s2 e1 e2)@(?E s2 e2) &[e1,e2])}>
	PUSH	DWORD PTR [ESP+8]
	CALL	tapp(_List?hd,<entry,ESP 1 1 se,EBP 1,cap[],&[e1,e2]>)
	ADD	ESP,4	
	UNPACK	ptr$1,EAX,EAX
	PUSH	DWORD PTR [EAX] 
	PUSH	DWORD PTR [ESP] 
	CALL	tapp(_Core?print_string,<ESP 1 2 se,EBP 1,cap[],&[e1,e2]>)
	MOV	[ESP],string$9
	CALL	tapp(_Core?print_string,<ESP 1 2 se,EBP 1,cap[],&[e1,e2]>)
	ADD	ESP,4           
	PUSH	DWORD PTR [ESP+12] 
	CALL	tapp(_List?tl,<entry,ESP 1 2 se,EBP 1,cap[],&[e1,e2]>)
	ADD	ESP,4	
	MOV	[ESP+12],EAX
	ADD	ESP,4
whiletest$7:
	JMP	tapp(whilebody$6,<s1,s2,e1,e2>)
whileend$8:
; 	End try body.
	ADD	ESP,4
	POP	EBP
	JMP	tapp(tryend$5,<s1,s2,e1,e2>)
trycatch$4:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2], \
EAX: ?exn,ESP: sptr (?Ha (`List?list? entry)::(?Sv s1 s2 e1 e2) s2 e1 e2)}>
	POP	EBP
	PUSH	EAX
	ADD	ESP,8
	RETN
tryend$5:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2], \
EBP: sptr (?E s2 e2),ESP: sptr (`List?list? entry)::(?Sv s1 s2 e1 e2)@(?E s2 e2)}>
	ADD	ESP,4
	RETN


;;;   
;;;    For debugging, prints out the portion of the symbol table referenced by 
;;;    a paticular handle
;;;
_print_handle_table:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2), \
	ESP: sptr (?Sv `handle_t?::s1 s2 e1 e2)@(?E s2 e2)}>
	PUSH	string$10
	CALL	tapp(_Core?print_string,<ESP 1 3 s1,EBP 1,e1,e2>)
	ADD	ESP,4
	MOV	EAX,unroll(unroll([ESP+4]))
	PUSH	DWORD PTR [EAX]
	PUSH	EBP
	PUSH	tapp(trycatch$11,<s1,s2,e1,e2>)
	MOV	EBP,ESP
; 	Begin try body.
	JMP	whiletest$14
whilebody$13:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[cap[],&[e1,e2]],\
	EBP: sptr (?E (sptr (?E s2 e2))::(`List?list? entry)::(?Sv `handle_t?::s1 s2 e1 e2)@(?E s2 e2) &[e1,e2]),ESP: sptr se@(?E (sptr (?E s2 e2))::(`List?list? entry)::(?Sv `handle_t?::s1 s2 e1 e2)@(?E s2 e2) &[e1,e2])}>
	PUSH	DWORD PTR [ESP+8]
	CALL	tapp(_List?hd,<entry,ESP 1 1 se,EBP 1,cap[],&[e1,e2]>)
	ADD	ESP,4
	UNPACK	ptr$1,EAX,EAX
	PUSH	DWORD PTR [EAX]
	PUSH	DWORD PTR [ESP]
	CALL	tapp(_Core?print_string,<ESP 1 2 se,EBP 1,cap[],&[e1,e2]>)
	MOV	[ESP],string$16
	CALL	tapp(_Core?print_string,<ESP 1 2 se,EBP 1,cap[],&[e1,e2]>)
	ADD	ESP,4
	PUSH	DWORD PTR [ESP+12]
	CALL	tapp(_List?tl,<entry,ESP 1 2 se,EBP 1,cap[],&[e1,e2]>)
	ADD	ESP,4
	MOV	[ESP+12],EAX
	ADD	ESP,4
whiletest$14:
	MOV	EAX,unroll(unroll([ESP+16]))
	MOV	ECX,[EAX+4]
	MOV	EAX,[ESP+8]
	CMP	EAX,ECX
	JNE	tapp(whilebody$13,<s1,s2,e1,e2>)
whileend$15:
; 	End try body.
	ADD	ESP,4
	POP	EBP
	JMP	tapp(tryend$12,<s1,s2,e1,e2>)
trycatch$11:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EAX: ?exn,\
ESP: sptr (?Ha (`List?list? entry)::(?Sv `handle_t?::s1 s2 e1 e2) s2 e1 e2)}>
	POP	EBP
	PUSH	EAX
	ADD	ESP,8
	RETN
tryend$12:
LABELTYPE <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),\
ESP: sptr (`List?list? entry)::(?Sv `handle_t?::s1 s2 e1 e2)@(?E s2 e2)}>
	ADD	ESP,4
	RETN

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;;     Typmatch and Cast
;;;

; Tail recursive version of typ_match_stack (at least for self call)
_typ_match_list:
LABELTYPE <All[va:typlist vb:typlist vc:Tm-!>T4 s1:Ts e1:Tcap e2:Tcap]. \
	code {cap: &[e1,e2],   \
	ESP: sptr (code { EAX:(`Core?Opt? (vc (interpTprod vb))), \
	           ESP:sptr s1,cap: &[e1,e2]}):: \
	(vc (interpTprod va))::(reptyplist va)::(reptyplist vb)::s1}>

	MOV	EAX,unroll([ESP+8])
	NAMEOBJ	uptr$6,EAX
	MOV	ECX,[EAX]
	CMP	ECX,0
	JE	Null_value$7
Cons_value$8:
	COERCE  rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$6
	LETROLL a1,va
	VCASE   1,beta1,a1,[EAX+4]
	MOV	EAX,unroll([ESP+16])
	NAMEOBJ	uptr$11,EAX
	MOV	ECX,[EAX]
	CMP	ECX,0
	JE	Null_value$13
Cons_value$12:
	COERCE 	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$11
	LETROLL a2,vb
	VCASE   1,beta2,a2,[EAX+4]
	MOV	EAX,[ESP]
	PUSH	DWORD PTR [EAX]
	MOV	EAX,[ESP+8]
	PUSH	DWORD PTR [EAX]
	PUSH	DWORD PTR [ESP+20]
	CALL	tapp(_typ_match,<beta1.0,beta2.0,fn a:T4.(vc (*[a^rw,interpTprod beta1.1])), \
		(^*[(reptyp beta2.0)^rw,(reptyplist beta2.1)^rw]):: \
		(^*[(reptyp beta1.0)^rw,(reptyplist beta1.1)^rw]):: \
		(code { EAX:(`Core?Opt? (vc (interpTprod vb))), ESP:sptr s1,cap: &[e1,e2]}):: \
		(vc (interpTprod va))::(reptyplist va)::(reptyplist vb)::s1,e1,e2>)
	COERCE	unroll(EAX)
	NAMEOBJ ptr$1,EAX
	CMP	DWORD PTR EAX,0
	JNE	iffalse$15
iftrue$14:
	COERCE  rec(forgetname(EAX))
	REMOVENAME ptr$1
	MOV	EAX,rollsum(<`Core?Opt? (vc (interpTprod vb))>,0)
	ADD	ESP,8
	RETN	12
iffalse$15:
	COERCE  unroll(rec(forgetname(EAX)))
	REMOVENAME ptr$1
	MOV	EAX,[EAX]
	MOV	EBX,[ESP+8]
	MOV	ECX,[ESP+4]
	MOV 	ECX,[ECX+4]
	MOV	EDX,[ESP]
	MOV	EDX,[EDX+4]
	ADD	ESP, 24
	PUSH 	EDX
	PUSH	ECX
	PUSH	EAX
	PUSH	EBX
	JMP 	tapp(_typ_match_list, <beta1.1, beta2.1, fn a:Tm. \
		(vc *[(interp beta2.0)^rw,a]),s1,e1,e2>)
Null_value$13:
	COERCE  rec(forgetname(EAX))
	REMOVENAME	uptr$11
	MOV	EAX,rollsum(<`Core?Opt? (vc (interpTprod vb))>,0)
	ADD	ESP,4
	RETN	12
Null_value$7:
	COERCE 	rec(forgetname(EAX))
	REMOVENAME	uptr$6
	LETROLL a1,va
	VCASE   0,beta1,a1,[EAX+4]
	MOV	EAX,unroll([ESP+12])
	NAMEOBJ	uptr$20,EAX
	MOV	ECX,[EAX]
	CMP	ECX,0
	JE	Null_value$21
Cons_value$22:
	COERCE  rec(forgetname(EAX))
	REMOVENAME	uptr$20
	MOV	EAX,rollsum(<`Core?Opt? (vc (interpTprod vb))>,0)
	RETN	12
Null_value$21:
	COERCE  rec(forgetname(EAX))	
	REMOVENAME	uptr$20
	LETROLL a2,vb
	VCASE   0,beta2,a2,[EAX+4]
	MALLOC	mptr$23,4
	MOV	EBX,EAX
	MOV	EAX,[ESP+4]
	MOV	[EBX],EAX
	FORGETUNIQUE	mptr$23
	MOV	EAX,rollsum(<`Core?Opt? (vc (interpTprod vb))>,    \
		roll(<^T(0)(`Core?Opt?mem (vc (interpTprod vb)))>,forgetname(EBX)))
	RETN	12

; Tail recursive version of typ_match_list (at least for self call)
; if we had kind polymorphism we could do this in one function....
_typ_match_stack:
LABELTYPE <All[va:typlist vb:typlist vc:Ts-!>T4 s1:Ts e1:Tcap e2:Tcap]. \
	code {cap: &[e1,e2],   \
	ESP: sptr (code { EAX:(`Core?Opt? (vc (interpTs vb))), \
	           ESP:sptr s1,cap: &[e1,e2]}):: \
	(vc (interpTs va))::(reptyplist va)::(reptyplist vb)::s1}>

	MOV	EAX,unroll([ESP+8])
	NAMEOBJ	uptr$6,EAX
	MOV	ECX,[EAX]
	CMP	ECX,0
	JE	SNull_value$7
SCons_value$8:
	COERCE  rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$6
	LETROLL a1,va
	VCASE   1,beta1,a1,[EAX+4]
	MOV	EAX,unroll([ESP+16])
	NAMEOBJ	uptr$11,EAX
	MOV	ECX,[EAX]
	CMP	ECX,0
	JE	SNull_value$13
SCons_value$12:
	COERCE 	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$11
	LETROLL a2,vb
	VCASE   1,beta2,a2,[EAX+4]
	MOV	EAX,[ESP]
	PUSH	DWORD PTR [EAX]
	MOV	EAX,[ESP+8]
	PUSH	DWORD PTR [EAX]
	PUSH	DWORD PTR [ESP+20]
	CALL	tapp(_typ_match,<beta1.0,beta2.0,\
		fn a:T4.(vc (a::(interpTs beta1.1))), \
		(^*[(reptyp beta2.0)^rw,(reptyplist beta2.1)^rw]):: \
		(^*[(reptyp beta1.0)^rw,(reptyplist beta1.1)^rw]):: \
		(code { EAX:(`Core?Opt? (vc (interpTs vb))), ESP:sptr s1,cap: &[e1,e2]}):: \
		(vc (interpTs va))::(reptyplist va)::(reptyplist vb)::s1,e1,e2>)
	COERCE	unroll(EAX)
	NAMEOBJ ptr$1,EAX
	CMP	DWORD PTR EAX,0
	JNE	Siffalse$15
Siftrue$14:
	COERCE  rec(forgetname(EAX))
	REMOVENAME ptr$1
	MOV	EAX,rollsum(<`Core?Opt? (vc (interpTs vb))>,0)
	ADD	ESP,8
	RETN	12
Siffalse$15:
	COERCE  unroll(rec(forgetname(EAX)))
	REMOVENAME ptr$1
	MOV	EAX,[EAX]
	MOV	EBX,[ESP+8]
	MOV	ECX,[ESP+4]
	MOV 	ECX,[ECX+4]
	MOV	EDX,[ESP]
	MOV	EDX,[EDX+4]
	ADD	ESP, 24
	PUSH 	EDX
	PUSH	ECX
	PUSH	EAX
	PUSH	EBX
	JMP 	tapp(_typ_match_stack, <beta1.1, beta2.1, fn a:Ts. \
		(vc ((interp beta2.0)::a)),s1,e1,e2>)
SNull_value$13:
	COERCE  rec(forgetname(EAX))
	REMOVENAME	uptr$11
	MOV	EAX,rollsum(<`Core?Opt? (vc (interpTs vb))>,0)
	ADD	ESP,4
	RETN	12
SNull_value$7:
	COERCE 	rec(forgetname(EAX))
	REMOVENAME	uptr$6
	LETROLL a1,va
	VCASE   0,beta1,a1,[EAX+4]
	MOV	EAX,unroll([ESP+12])
	NAMEOBJ	uptr$20,EAX
	MOV	ECX,[EAX]
	CMP	ECX,0
	JE	SNull_value$21
SCons_value$22:
	COERCE  rec(forgetname(EAX))
	REMOVENAME	uptr$20
	MOV	EAX,rollsum(<`Core?Opt? (vc (interpTs vb))>,0)
	RETN	12
SNull_value$21:
	COERCE  rec(forgetname(EAX))	
	REMOVENAME	uptr$20
	LETROLL a2,vb
	VCASE   0,beta2,a2,[EAX+4]
	MALLOC	mptr$23,4
	MOV	EBX,EAX
	MOV	EAX,[ESP+4]
	MOV	[EBX],EAX
	FORGETUNIQUE	mptr$23
	MOV	EAX,rollsum(<`Core?Opt? (vc (interpTs vb))>,    \
		roll(<^T(0)(`Core?Opt?mem (vc (interpTs vb)))>,forgetname(EBX)))
	RETN	12

_typ_match:
LABELTYPE <All[va:typ vb:typ vc:T4-!>T4 s1:Ts  e1:Tcap e2:Tcap].code {cap: &[e1,e2],\
	ESP: sptr (code {cap:&[e1,e2],EAX:(`Core?Opt? (vc (interp vb))), ESP:sptr s1}):: \
	(vc (interp va))::(reptyp va)::(reptyp vb)::s1}>

	MOV	EAX,unroll([ESP+8])
	NAMEOBJ	uptr$26,EAX
	MOV	ECX,[EAX]
	CMP	ECX,8
	JE	Tuple_value$30
	CMP	ECX,7
	JE 	Vfn_value$1
	CMP 	ECX,6
	JE 	Fn_value$1
	CMP 	ECX,5
	JE	Array_value$1
	CMP	ECX,4
	JE	Char_value$29
	CMP	ECX,3
	JE	String_value$28
	CMP	ECX,2
	JE	Bool_value$27
	CMP	ECX,1
	JE	Int_value$1
	CMP	ECX,0
	JE	Exn_value$1
	JMP	default$25
Int_value$1:
	COERCE	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$26
	; type refinement
	LETROLL alpha,va
	VCASE 	1,beta,alpha,[EAX+4]
	MOV	EAX,unroll([ESP+16])
	NAMEOBJ	uptr$33,EAX
	MOV	ECX,[EAX]
	CMP	ECX,1
	JE	Int_value$2
	JMP	default$32
Int_value$2:
	COERCE  rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$33
	; type refinement
	LETROLL alpha2,vb
	VCASE 	1,beta2,alpha2,[EAX+4]
	MOV	EAX,[ESP]
	PUSH	DWORD PTR [EAX]
	MOV	EAX,[ESP+8]
	MOV	EAX,[EAX]
	POP	ECX
	CMP	EAX,ECX
	JNE	iffalse$110
condtrue$112:
	MOV	EAX,[ESP]
	PUSH	DWORD PTR [EAX+4]
	MOV	EAX,[ESP+8]
	MOV	EAX,[EAX+4]
	POP	ECX
	CMP	EAX,ECX
	JNE	iffalse$110
iftrue$109:
	MALLOC	mptr$113,4
	MOV	EBX,EAX
	MOV	EAX,[ESP+12]
	MOV	[EBX],EAX
	FORGETUNIQUE	mptr$113
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>,roll(<(fn va:T4 . ^T(0)(`Core?Opt?mem va)) (vc (interp vb))>,forgetname(EBX)))
	ADD	ESP,8
	RETN	12
iffalse$110:
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>,0)
	ADD	ESP,8
	RETN	12
		

Tuple_value$30:
	COERCE	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$26
	; type refinement
	LETROLL alpha,va
	VCASE 	8,beta,alpha,[EAX+4]
	MOV	EAX,unroll([ESP+16])
	NAMEOBJ	uptr$33,EAX
	MOV	ECX,[EAX]
	CMP	ECX,8
	JE	Tuple_value$34
	JMP	default$32
Tuple_value$34:
	COERCE  rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$33
	; type refinement
	LETROLL alpha2,vb
	VCASE 	8,beta2,alpha2,[EAX+4]
	PUSH	DWORD PTR [ESP]
	PUSH	DWORD PTR [ESP+8]
	PUSH	DWORD PTR [ESP+20]
	CALL	tapp(_typ_match_list,<beta,beta2,(fn a:Tm.vc (^a)),\
	(reptyplist beta2)::(reptyplist beta):: \
	(code {cap: &[e1,e2],EAX:(`Core?Opt? (vc (interp vb))), ESP:sptr s1}):: \
	(vc (interp va))::(reptyp va)::(reptyp vb)::s1, e1,e2>)
	ADD	ESP,8
	RETN	12
default$32:
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>,0)
	ADD	ESP,4
	RETN	12

Exn_value$1:
	COERCE	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$26
;  refinement
	LETROLL alphaC1,va
	VCASE 	0,betaC1,alphaC1,[EAX+4]
	MOV	EAX,unroll([ESP+16])
	NAMEOBJ	uptr$37,EAX
	MOV	ECX,[EAX]
	CMP	ECX,0
	JE	Exn_value$2
	JMP	default$exn
Exn_value$2:
	COERCE	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$37
; refinement
	LETROLL alphaC2,vb
	VCASE 	0,betaC2,alphaC2,[EAX+4]
	MALLOC	mptr$39,4
	MOV	EBX,EAX
	MOV	EAX,[ESP+12]
	MOV	[EBX],EAX
	FORGETUNIQUE	mptr$39
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>, \
		roll(<^T(0)(`Core?Opt?mem (vc (interp vb)))>,forgetname(EBX)))
	ADD	ESP,8
	RETN 	12
default$exn:
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>,0)
	ADD	ESP,4
	RETN 	12

Vfn_value$1:
	COERCE	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$26
	; type refinement
	LETROLL alpha,va
	VCASE 	7,beta,alpha,[EAX+4]
	MOV	EAX,unroll([ESP+16])
	NAMEOBJ	uptr$33,EAX
	MOV	ECX,[EAX]
	CMP	ECX,7
	JE	Vfn_value$2
	JMP	default$vfn
Vfn_value$2:
	COERCE  rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$33
	; type refinement
	LETROLL alpha2,vb
	VCASE 	7,beta2,alpha2,[EAX+4]
	PUSH	DWORD PTR [ESP]
	PUSH	DWORD PTR [ESP+8]
	PUSH	DWORD PTR [ESP+20]
	CALL	tapp(_typ_match_stack,<beta,beta2,(fn b:Ts.vc  (vfntype b)), \
 	(reptyplist beta2)::(reptyplist beta):: \
	(code {cap:&[e1,e2],EAX:(`Core?Opt? (vc (interp vb))), ESP:sptr s1}):: \
	(vc (interp va))::(reptyp va)::(reptyp vb)::s1, e1,e2>)
	ADD	ESP,8
	RETN	12
default$vfn:
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>,0)
	ADD	ESP,4
	RETN	12

Fn_value$1:
	COERCE	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$26
	; type refinement
	LETROLL alpha,va
	VCASE 	6,beta1,alpha,[EAX+4]
	MOV	EAX,unroll([ESP+16])
	NAMEOBJ	uptr$33,EAX
	MOV	ECX,[EAX]
	CMP	ECX,6
	JE	Fn_value$2
	JMP	default$fn
Fn_value$2:
	COERCE  rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$33
	; type refinement
	LETROLL alpha2,vb
	VCASE 	6,beta2,alpha2,[EAX+4]
	MOV	EAX,[EAX+4]
	PUSH	DWORD PTR [EAX+4]    ; reptyplist beta2.1
	MOV	EAX,[ESP+8]
	PUSH	DWORD PTR [EAX+4]    ; reptyplist beta.1		
	PUSH	DWORD PTR [ESP+20]
	CALL	tapp(_typ_match_stack,<beta1.1,beta2.1, \
	(fn b:Ts. vc (fntype (interp beta1.0) b)), \
 	(^*[(reptyp beta2.0)^rw,(reptyplist beta2.1)^rw]):: \
	(^*[(reptyp beta1.0)^rw,(reptyplist beta1.1)^rw]):: \
	(code {cap: &[e1,e2],EAX:(`Core?Opt? (vc (interp vb))), ESP:sptr s1}):: \
	(vc (interp va))::(reptyp va)::(reptyp vb)::s1,e1,e2>)
	; now examine return value
	COERCE 	unroll(EAX)
	NAMEOBJ ptr$1,EAX
	CMP	DWORD PTR EAX,0
	JNE	iffalse$fn
iftrue$fn:
	COERCE  rec(forgetname(EAX))
	REMOVENAME ptr$1
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>,0)
	ADD	ESP,8
	RETN	12
iffalse$fn:
	COERCE  unroll(rec(forgetname(EAX)))
	REMOVENAME ptr$1
	; rearrange the stack to do a tail call to interp 
	MOV	EAX,[EAX]	; return value from last call
	MOV	EBX,[ESP+8]    ; return address
	MOV	ECX,[ESP+4]    ; rep of beta
	MOV	EDX,[ESP]    ; rep of beta2
	ADD	ESP,24
	PUSH 	DWORD PTR [EDX+0]
	PUSH 	DWORD PTR [ECX+0]
	PUSH 	EAX
	PUSH	EBX	
	JMP 	tapp(_typ_match, <beta1.0, beta2.0, fn a:T4. vc (fntype a (interpTs beta2.1)), \
			s1,e1,e2>) 
default$fn:
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>,0)
	ADD	ESP,4
	RETN	12

Array_value$1:
	COERCE	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$26
	; type refinement
	LETROLL alpha,va
	VCASE 	5,beta,alpha,[EAX+4]
	MOV	EAX,unroll([ESP+16])
	NAMEOBJ	uptr$33,EAX
	MOV	ECX,[EAX]
	CMP	ECX,5
	JE	Array_value$2
	JMP	default$array
Array_value$2:
	COERCE  rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$33
	; type refinement
	LETROLL alpha2,vb
	VCASE 	5,beta2,alpha2,[EAX+4]
	PUSH	DWORD PTR [ESP]
	PUSH	DWORD PTR [ESP+8]
	PUSH	DWORD PTR [ESP+20]
	CALL	tapp(_typ_match,<beta,beta2,(fn b:T4.vc  (?arr b)), \
 	(reptyp beta2)::(reptyp beta):: \
	(code {cap: &[e1,e2],EAX:(`Core?Opt? (vc (interp vb))), ESP:sptr s1}):: \
	(vc (interp va))::(reptyp va)::(reptyp vb)::s1, e1, e2>)
	ADD	ESP,8
	RETN	12
default$array:
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>,0)
	ADD	ESP,4
	RETN	12

Char_value$29:
	COERCE	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$26
;  refinement
	LETROLL alphaC1,va
	VCASE 	4,betaC1,alphaC1,[EAX+4]
	MOV	EAX,unroll([ESP+16])
	NAMEOBJ	uptr$37,EAX
	MOV	ECX,[EAX]
	CMP	ECX,4
	JE	Char_value$38
	JMP	default$36
Char_value$38:
	COERCE	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$37
; refinement
	LETROLL alphaC2,vb
	VCASE 	4,betaC2,alphaC2,[EAX+4]
	MALLOC	mptr$39,4
	MOV	EBX,EAX
	MOV	EAX,[ESP+12]
	MOV	[EBX],EAX
	FORGETUNIQUE	mptr$39
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>, \
		roll(<^T(0)(`Core?Opt?mem (vc (interp vb)))>,forgetname(EBX)))
	ADD	ESP,8
	RETN 	12
default$36:
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>,0)
	ADD	ESP,4
	RETN 	12
String_value$28:
	COERCE 	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME uptr$26
	LETROLL alphaS1,va
	VCASE 	3,betaS1,alphaS1,[EAX+4]
	MOV	EAX,unroll([ESP+16])
	NAMEOBJ	uptr$42,EAX
	MOV	ECX,[EAX]
	CMP	ECX,3
	JE	String_value$43
	JMP	default$41
String_value$43:
	COERCE 	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$42
	LETROLL alphaS2,vb
	VCASE 	3,betaS2,alphaS2,[EAX+4]	
	MALLOC	mptr$44,4
	MOV	EBX,EAX
	MOV	EAX,[ESP+12]
	MOV	[EBX],EAX
	FORGETUNIQUE	mptr$44
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>, \
		roll(<^T(0)(`Core?Opt?mem (vc (interp vb)))>,forgetname(EBX)))
	ADD	ESP,8
	RETN 	12
default$41:
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>,0)
	ADD	ESP,4
	RETN 	12
Bool_value$27:
	COERCE 	rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$26
	LETROLL alphaS1,va
	VCASE 	2,betaS1,alphaS1,[EAX+4]
	MOV	EAX,unroll([ESP+16])
	NAMEOBJ	uptr$47,EAX
	MOV	ECX,[EAX]
	CMP	ECX,2
	JE	Bool_value$48
	JMP	default$46
Bool_value$48:
	COERCE  rec(forgetname(EAX))
	PUSH	DWORD PTR [EAX+4]
	REMOVENAME	uptr$47
	LETROLL alphaB2,vb
	VCASE 	2,betaB2,alphaB2,[EAX+4]	
	MALLOC	mptr$49,4
	MOV	EBX,EAX
	MOV	EAX,[ESP+12]
	MOV	[EBX],EAX
	FORGETUNIQUE	mptr$49
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>, \
		roll(<^T(0)(`Core?Opt?mem (vc (interp vb)))>,forgetname(EBX)))
	ADD	ESP,8
	RETN 	12
default$46:
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>,0)
	ADD	ESP,4
	RETN 	12
default$25:
	MOV	EAX,rollsum(<`Core?Opt? (vc (interp vb))>,0)
	RETN 	12

;; A wrapper for typ-match 
_cast:
LABELTYPE <All[va:typ vb:typ s1:Ts s2:Ts e1:Tcap e2:Tcap].code { cap: &[e1,e2],EBP: sptr (?E s2 e2), \
	ESP: sptr (?S (`Core?Opt? (interp vb)) (interp va)::(reptyp va)::(reptyp vb)::s1 \
	 s2 e1 e2)@(?E s2 e2)}>
	PUSH 	EBP
	PUSH 	DWORD PTR [ESP+16]
	PUSH 	DWORD PTR [ESP+16]
	PUSH 	DWORD PTR [ESP+16]
	CALL	tapp(_typ_match,<va,vb,fn d:T4.d, 	\
		(sptr (?E s2 e2)):: \
		(?S (`Core?Opt? (interp vb)) (interp va)::(reptyp va)::(reptyp vb)::s1 s2 e1 e2) \
		@(?E s2 e2), e1,e2>)
	POP	EBP
	RETN



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;      DATA   SEGMENT 
;;;;;;;;;


	DATA

string$30:
LABELTYPE<^*[Rep(type inittype)]>
	DREP 	TYPE inittype
;; rb 
string$22:
COERCE	pack(<2>,array(4,0,<B1^rw>,?),<?str>)
	DD	2
	TAL_STRUCT
	DB	114,98
string$23:
COERCE	pack(<2>,array(4,0,<B1^rw>,?),<?str>)
	DD	2
	TAL_STRUCT
	DB	114,98
;; .to
string$21:
COERCE	pack(<3>,array(4,0,<B1^rw>,?),<?str>)
	DD	3
	TAL_STRUCT
	DB	46,116,111
;; .obj
string$20:
COERCE	pack(<4>,array(4,0,<B1^rw>,?),<?str>)
	DD	4
	TAL_STRUCT
	DB	46,111,98,106

;; global symbol table
_symbol_table:
LABELTYPE <^*[(`List?list? entry)^rw]>
	DD	rollsum(<`List?list? entry>,0)

;; exceptions that may be raised 
FailsTypeCheck?exn:
LABELTYPE <?exnname B4^r>
	DD	?
SymbolNotFound?exn:
LABELTYPE <?exnname ?str^r>
	DD	?
WrongType?exn:
LABELTYPE <?exnname ?str^r>
	DD	?

;; Strings for print_table
; symbol table contains:
string$3:
COERCE	pack(<22>,array(4,0,<B1^rw>,?),<?str>)
	DD	22
	TAL_STRUCT
	DB	83,121,109,98,111,108,32,116,97,98,108,101,32,99,111,110,116,97,105,110,115,10
; newline
string$9:
COERCE	pack(<1>,array(4,0,<B1^rw>,?),<?str>)
	DD	1
	TAL_STRUCT
	DB	10
string$16:
COERCE	pack(<1>,array(4,0,<B1^rw>,?),<?str>)
	DD	1
	TAL_STRUCT
	DB	10

string$10:
COERCE	pack(<30>,array(4,0,<B1^rw>,?),<?str>)
	DD	30
	TAL_STRUCT
	DB	72,97,110,100,108,101,32,115,121,109,98,111,108,32,116,97,98,108,101,32,99,111,110,116,97,105,110,115,58,10


;; "Compiler bug detected in print_string"
string$61:
COERCE	pack(<37>,array(4,0,<B1^rw>,?),<?str>)
	DD	37
	TAL_STRUCT
	DB	67,111,109,112,105,108,101,114,32,98,117,103,32,100,101,116,101,99,116,101,100,32,105,110,32,112,114,105,110,116,95,115
	DB	116,114,105,110,103


	_end_TAL
	END
