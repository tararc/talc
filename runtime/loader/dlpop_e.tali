; TAL INTERFACE bar_e
; This file was generated by TALC
        TYPE    <?arr = fn c:T . Exist[?sz:Sint].^*[S(?sz)^r,(^*[array(?sz,c^rw)])^r]>
        TYPE    <?str = Exist[?sz:Sint].^*[S(?sz)^r,(^*[array(?sz,B1^rw)])^r]>
        TYPE    <?exnname = fn c$0:Tm . ^T^rw(c$0)*[junk 4]>
        TYPE    <?exn = Exist[c$0:Tm].^*[(?exnname c$0)^r,c$0]>
        TYPE    <?H = fn s:Ts e:Tcap . code {cap: e,EAX: ?exn,ESP: sptr s}>
        TYPE    <?E = fn s:Ts e:Tcap . (?H s e)::s>
        TYPE    <?S = fn ?ret:T4 ?s1:Ts ?s2:Ts ?e1:Tcap ?e2:Tcap . (code {cap: &[?e1,?e2],EAX: ?ret,EBP: sptr (?E ?s2 ?e2),ESP: sptr ?s1@(?E ?s2 ?e2)})::?s1>
        TYPE    <?Sv = fn ?s1:Ts ?s2:Ts ?e1:Tcap ?e2:Tcap . (code {cap: &[?e1,?e2],EBP: sptr (?E ?s2 ?e2),ESP: sptr ?s1@(?E ?s2 ?e2)})::?s1>
        TYPE    <?Sf = fn ?s1:Ts ?s2:Ts ?e1:Tcap ?e2:Tcap . (code {cap: &[?e1,?e2],ST0,EBP: sptr (?E ?s2 ?e2),ESP: sptr ?s1@(?E ?s2 ?e2)})::?s1>
        TYPE    <?Ha = fn ?s1:Ts ?s2:Ts ?e1:Tcap ?e2:Tcap . (sptr (?E ?s2 ?e2))::(?s1@(?E ?s2 ?e2))>

kind <var = Sint>
kind <unit = *[] >
kind <bool = +[ unit,     \ ; false
		unit ] >    ; true
kind <size = +[ unit,     \ ; B1
	        unit,     \ ; B2
	        unit ]>     ; B4

reckind <typlist = +[ unit, *[typ, typlist]]>
andkind <typ = +[ unit,      \ ; exn 
	       *[bool,size], \ ; int 
	       unit,      \ ; bool
               unit,      \ ; string 
	       unit,      \ ; char
	       typ,       \ ; array (can't specify size)
	       *[typ,typlist], \ ; mono-morphic functions (returning a value)
	       typlist, \   ; mono-morphic functions (returning void)
	       typlist \   ; tuples
\;	       ,*[Sint, typlist], \
\;	       *[Sint, typlist]  \
 ]>   
              ; need structs, unions
kind <utyplist = +[ unit, *[typ, typlist]]>
kind <utyp =  +[ unit,      \ ; exn 
	       *[bool,size], \ ; int 
	       unit,      \ ; bool
               unit,      \ ; string 
	       unit,      \ ; char
	       typ,       \ ; array (can't specify size)
               *[typ,typlist], \ ; mono functions
	       typlist, \   ;  mono-morphic functions (returning void)
	       typlist]>    ; tuples

reckind <Tlist  = +[unit, *[T, Tlist]]>
kind    <uTlist = +[unit, *[T, Tlist]]>

; Abbreviations for the types of popcorn functions
type < fntype = fn ret:T4 args:Ts. \
 (All[s1:Ts s2:Ts e1:Tcap e2:Tcap]. code {cap: &[e1,e2], EBP: sptr (?E s2 e2), ESP: sptr  \
   (?S ret (args@s1) s2 e1 e2)@(?E s2 e2)})>
type < vfntype = fn args:Ts. \
 (All[s1:Ts s2:Ts e1:Tcap e2:Tcap]. code {cap: &[e1,e2], EBP: sptr (?E s2 e2), ESP: sptr  \
   (?Sv (args@s1) s2 e1 e2)@(?E s2 e2)})>

type <crexn = roll [typ] (inj 0 [] [utyp])>
type <crint = fn a:bool b:size. roll [typ] (inj 1 [a,b] [utyp])>
type <crbool = roll [typ] (inj 2 [] [utyp])>
type <crstring = roll [typ] (inj 3 [] [utyp])>
type <crchar = roll [typ] (inj 4 [] [utyp])>
type <crarray = fn a:typ. roll [typ] (inj 5 a [utyp])>
type <crfn = fn a:typ b:typlist. roll [typ] (inj 6 [a,b] [utyp])>
type <crvfn = fn a:typlist. roll [typ] (inj 7 a [utyp])>
type <crtuple = fn a:typlist . roll [typ] (inj 8 a [utyp])>

type <crnull = roll [typlist] (inj 0 [] [utyplist])>
type <crcons = fn a: typ b:typlist. roll [typlist] (inj 1 [a,b] [utyplist])>

type <crfalse = inj 0 [] [bool]>
type <crtrue = inj 1 [] [bool]>

type <crb1 = inj 0 [] [size]>
type <crb2 = inj 1 [] [size]>
type <crb4 = inj 2 [] [size]>

; Produce the TAL type from the popcorn type
primrec <interpTprod : typlist -!> Tm = fn a:+[ *[], *[typ, typlist]].  \
	case (a) b [ *[], \
	             *[ (interp (b.0))^rw, interpTprod (b.1)]]>
andprim <interpTs : typlist -!> Ts = fn a:+[ *[], *[typ, typlist]].  \
	case (a) b [ se, \
	             (interp b.0)::(interpTs (b.1))]>
andprim <interp : typ -!> T4 = fn a:+[ unit,      \ ; Void 
	       *[bool,size], \ ; int 
	       unit,      \ ; bool
               unit,      \ ; string 
	       unit,      \ ; char
	       typ,       \ ; array (can't specify size)
               *[typ,typlist], \ ; mono functions
	       typlist,   \
	       typlist] . \
	(case (a) b [ ?exn,                \  ; exception
	   	      B4,                     \  ; int 	
	              ^T[0,1], 		      \  ; bool
		      ?str, 		      \  ; str
		      B4, 	 	      \  ; char 
		      ?arr (interp b),         \  ; array
		      fntype (interp (b.0)) (interpTs (b.1)), \
		      vfntype (interpTs b), \
                      ^(interpTprod b)])>

primrec < unrol_typlist : typlist -!> +[unit, *[typ, typlist]] =  \
	fn a: +[unit, *[typ, typlist]] . a >
andprim <unrol_typ : typ -!>+[ unit,      \ ; exception
	       *[bool,size], \ ; int 
	       unit,      \ ; bool
               unit,      \ ; string 
	       unit,      \ ; char
	       typ,       \ ; array (can't specify size)
               *[typ,typlist], \ ; mono functions
	       typlist,        \ ; mono void returning functions
	       typlist]  = fn a:+[ unit,      \ ; exception
	       *[bool,size], \ ; int 
	       unit,      \ ; bool
               unit,      \ ; string 
	       unit,      \ ; char
	       typ,       \ ; array (can't specify size)
               *[typ,typlist], \ ; mono functions
	       typlist,     \
	       typlist] . a>
;
; Create the type of the representation of it. 
type    < repbool = fn a:bool . S (case (a) b [0, 1])>
type    < repsize = fn a:size . S (case (a) b [0, 1, 2])>

type    < rep = rec (   \
	   reptyp : typ -!> T4. fn a: typ. \
	     ^+[ *[S(0)^r, (case (unrol_typ a) b			       \
		     [ B4, void[T4], void[T4], void[T4], void[T4],        \
	               void[T4], void[T4], void[T4], void[T4]])^rw],   \
	        *[S(1)^r, (case (unrol_typ a) b			       \
		     [ void[T4], ^*[(repbool (b.0))^rw, (repsize (b.1))^rw], \
					   void[T4], void[T4], void[T4],        \
	               void[T4], void[T4], void[T4], void[T4]])^rw],   \
	        *[S(2)^r, (case (unrol_typ a) b			       \
		     [ void[T4], void[T4], B4, void[T4], void[T4],        \
	               void[T4], void[T4], void[T4], void[T4]])^rw],   \
	        *[S(3)^r, (case (unrol_typ a) b			       \
		     [ void[T4], void[T4], void[T4], B4, void[T4],       \
	              void[T4], void[T4], void[T4], void[T4]])^rw],   \
	        *[S(4)^r, (case (unrol_typ a) b			       \
		     [ void[T4], void[T4], void[T4], void[T4],         \
	               B4,void[T4], void[T4], void[T4], void[T4]])^rw],   \
	        *[S(5)^r, (case (unrol_typ a) b			       \
		     [ void[T4], void[T4], void[T4], void[T4],         \
	               void[T4], reptyp b, void[T4],  void[T4], void[T4]])^rw],   \
	        *[S(6)^r, (case (unrol_typ a) b			   \    
		     [ void[T4], void[T4], void[T4], void[T4],     \    
	               void[T4], void[T4], ^*[(reptyp (b.0))^rw,  \ 
			(reptyplist (b.1))^rw],  void[T4], void[T4]])^rw],   \ 
	        *[S(7)^r, (case (unrol_typ a) b			       \
		     [ void[T4], void[T4], void[T4], void[T4],         \
	               void[T4], void[T4], void[T4], reptyplist b, void[T4] ])^rw],   \
	        *[S(8)^r, (case (unrol_typ a) b			       \
		     [ void[T4], void[T4], void[T4], void[T4],         \
	               void[T4], void[T4], void[T4], void[T4], reptyplist b])^rw]],  \
	   reptyplist : typlist -!> T4 . fn a: typlist. \
	      ^+[*[S(0)^r, (case (unrol_typlist a) b \
		     [ B4, void[T4] ])^rw],          \
		*[S(1)^r, (case (unrol_typlist a) b \
		     [ void[T4], ^*[(reptyp (b.0))^rw, \
		                    (reptyplist (b.1))^rw]])^rw]])>
	TYPE <reptyp = rep.0>
	TYPE <reptyplist = rep.1>

	TYPE <initfntype = (All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),\
	ESP: sptr (?Sv (All[va:typ s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],		\
	EBP: sptr (?E s2 e2),ESP: sptr (?S (interp va) ?str::(reptyp va)::s1 s2 e1 e2)@(?E s2 e2)})::	\
	(All[va:typ s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),	\
	ESP: sptr (?Sv ?str::(reptyp va)::(interp va)::s1 s2 e1 e2)@(?E s2 e2)})::s1 \
	s2 e1 e2)@(?E s2 e2)})>

	TYPE 	<inittype = *[initfntype^rw]>

	TYPE	<handle_t? :T4 > 

	VAL	_dlopen,<All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?S `handle_t? ?str::s1 s2 e1 e2)@(?E s2 e2)}>
	VAL	_dlsym,<All[va:typ s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),\
		ESP: sptr (?S (interp va) `handle_t?::?str::(reptyp va)::s1 s2 e1 e2)@(?E s2 e2)}>
	VAL 	_add_symbol,<All[va:typ s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2), \
		ESP: sptr (?Sv ?str::(reptyp va)::(interp va)::s1 s2 e1 e2)@(?E s2 e2)}>
	VAL     _print_table,<All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?Sv s1 s2 e1 e2)@(?E s2 e2)}>
	VAL 	_print_handle_table, <All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2), \
	ESP: sptr (?Sv `handle_t?::s1 s2 e1 e2)@(?E s2 e2)}>

	VAL 	_dlpop?lookup_symbol,<All[va:typ s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2), \
		ESP: sptr (?S (interp va) ?str::(reptyp va)::s1 s2 e1 e2)@(?E s2 e2)}>
	VAL	_dlinit,<All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2), \
	ESP: sptr (?Sv (initfntype)::s1 s2 e1 e2)@(?E s2 e2)}>
	VAL	_dlclose,<All[s1:Ts s2:Ts e1:Tcap e2:Tcap].code {cap: &[e1,e2],EBP: sptr (?E s2 e2),ESP: sptr (?Sv `handle_t?::s1 s2 e1 e2)@(?E s2 e2)}>


	VAL	WrongType?exn,<?exnname ?str^r>
	VAL	SymbolNotFound?exn,<?exnname ?str^r>
	VAL	FailsTypeCheck?exn,<?exnname B4^r>



