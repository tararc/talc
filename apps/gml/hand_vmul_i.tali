; TAL INTERFACE rtcg_src/matrix_strap_i.tali
; This file was generated by POP TALC
	TYPE	<exn =Exist[c:Tm].^*[(^T^rw(c)*[B4^rw])^r,c]>
	TYPE	<arr =fn ?e:Tm . Exist[?sz:Sint].^*[S(?sz)^r,(^*[array(?sz,?e)])^r]>
	TYPE	<str =arr B1^rw>
	TYPE	<H =fn e2:Tcap s2:Ts . code{cap: e2,EDI:junk4,ESI:junk4,EBX:junk4,EAX:exn,ESP:sptr s2}>
	TYPE	<F =fn ret:T4 args:Ts rargs:Ts . All[a1:T4 a2:T4 a3:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code{cap: &[e1,e2],ESP:sptr (code{cap: &[e1,e2],EAX:ret,EBX:a1,EBP:sptr (H e2 s2)::s2,ESI:a2,EDI:a3,ESP:sptr rargs#s1#(H e2 s2)::s2})::(args#s1#(H e2 s2)::s2),EBP:sptr (H e2 s2)::s2,EBX:a1,ESI:a2,EDI:a3}>
	TYPE	<Fv =fn args:Ts rargs:Ts . All[a1:T4 a2:T4 a3:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code{cap: &[e1,e2],ESP:sptr (code{cap: &[e1,e2],ESP:sptr rargs#s1#(H e2 s2)::s2,EBP:sptr (H e2 s2)::s2,EDI:a3,ESI:a2,EBX:a1})::(args#s1#(H e2 s2)::s2),EBP:sptr (H e2 s2)::s2,EDI:a3,ESI:a2,EBX:a1}>
	TYPE	<Ff =fn args:Ts rargs:Ts . All[a1:T4 a2:T4 a3:T4 s1:Ts s2:Ts e1:Tcap e2:Tcap].code{cap: &[e1,e2],ESP:sptr (code{cap: &[e1,e2],ST0,ESP:sptr rargs#s1#(H e2 s2)::s2,EBP:sptr (H e2 s2)::s2,EDI:a3,ESI:a2,EBX:a1})::(args#s1#(H e2 s2)::s2),EBP:sptr (H e2 s2)::s2,EDI:a3,ESI:a2,EBX:a1}>
	TYPE	<FILE? :T4 = ^T(0)`FILE?mem>
	TYPE	<FILE?mem :Tm>
	TYPE	<Hashtable?table? :T4-!>T4-!>T4>
	TYPE	<Core?Opt? :T4-!>T4 = fn va:T4 . ^T(0)(`Core?Opt?mem va)>
	TYPE	<Core?Opt?mem :T4-!>Tm 4 = fn va:T4 . *[va^rw]>
	TYPE	<memType? :T4 = ^T(0)`memType?mem>
	TYPE	<memType?mem :Tm 4 = *[B4^rw]>

;; Added types here.
	TYPE	<Matrix?vector? :T4 = ^`Matrix?vector?mem>
	TYPE	<Matrix?vector?mem :Tm 32 = *[F8^rw,F8^rw,F8^rw,F8^rw]>
	TYPE	<Matrix?vectorA =^`Matrix?vector?mem>

	TYPE	<Matrix?matrix? :T4 = ^`Matrix?matrix?mem>
	TYPE	<Matrix?matrix?mem :Tm 128 = *[F8^rw,F8^rw,F8^rw,F8^rw,F8^rw,F8^rw,F8^rw,F8^rw,F8^rw,F8^rw,F8^rw,F8^rw,F8^rw,F8^rw,F8^rw,F8^rw]>
	TYPE	<Matrix?matrixA =^`Matrix?matrix?mem>

	TYPE	<Matrix?matrix_desc? :T4 = ^`Matrix?matrix_desc?mem>
	TYPE	<Matrix?matrix_desc?mem :Tm 16 = *[(arr B4^rw)^rw,B4^rw,B4^rw,B4^rw]>
	TYPE	<Matrix?matrix_descA =^`Matrix?matrix_desc?mem>


	VAL	ArrayBounds?exn,<^T^rw(B4^rw)*[B4^rw]>
	VAL	ArrayBounds?exn?pkt,<^*[exn^rw]>
	VAL	Core?Failure?exn,<^T^rw(str^rw)*[B4^rw]>
	VAL	NullPointer?exn,<^T^rw(B4^rw)*[B4^rw]>
	VAL	NullPointer?exn?pkt,<^*[exn^rw]>
	VAL	UnionVariant?exn,<^T^rw(B4^rw)*[B4^rw]>
	VAL	UnionVariant?exn?pkt,<^*[exn^rw]>
	VAL	_Hashtable?create,<All[va:T4 vb:T4].(F (`Hashtable?table? va vb) B4::(F B4 va::va::se junk 8::se)::(F B4 va::se junk 4::se)::se junk 12::se)>
	VAL	_Hashtable?insert,<All[va:T4 vb:T4].(Fv (`Hashtable?table? va vb)::va::vb::se junk 12::se)>
	VAL	_Hashtable?lookup,<All[va:T4 vb:T4].(F vb (`Hashtable?table? va vb)::va::se junk 8::se)>
	VAL	_Math?cos,<Ff F8::se junk 8::se>
	VAL	_Math?sin,<Ff F8::se junk 8::se>
	VAL	_Math?sqrt,<Ff F8::se junk 8::se>
	VAL	_fprint_double,<Fv `FILE?::F8::se junk 12::se>
	VAL	_fprint_int,<Fv `FILE?::B4::se junk 8::se>
	VAL	_fprint_string,<Fv `FILE?::str::se junk 8::se>
	VAL	_hash,<All[va:T4].(F B4 va::se junk 4::se)>
	VAL	_new_array,<All[va:T4].(F (arr va^rw) B4::va::se junk 8::se)>
	VAL	_ptr_compare,<All[va:T4].(F B4 va::va::se junk 8::se)>
	VAL	_tal_stdout,<^*[`FILE?^rw]>

; Additions below here.
	VAL	_Matrix?matrix2desc,<F `Matrix?matrix_desc? `Matrix?matrix?::se junk 4::se>
	VAL 	_Matrix?matrix_desc_hash,<F B4 `Matrix?matrix_desc?::se junk 4::se>
	VAL 	_Matrix?matrix_desc_cmp,<F B4 `Matrix?matrix_desc?::`Matrix?matrix_desc?::se junk 8::se>
	VAL _Matrix?vmul,<Fv `Matrix?vector?::`Matrix?matrix?::`Matrix?vector?::se junk 12::se>
