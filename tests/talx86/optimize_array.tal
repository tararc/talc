; TAL IMPLEMENTATION check_array3
; This file was generated by TALC
	INCLUDE	TAL.INC
	_begin_TAL


	TAL_IMPORT	pop_runtime.tali
	TAL_IMPORT	optimize_array_i.tali

	TAL_EXPORT	tal_prog.tali
	TAL_EXPORT	optimize_array_e.tali

	TYPE	<bogus_option$1 :T4 = ^T[0]>

	CODE

__main$:
LABELTYPE <All[s1:Ts s2:Ts cg:Tt].code {TLA: ^*[cg^rw],EBP: sptr (?E s2 cg),ESP: sptr (?Sv s1 s2 cg)@(?E s2 cg)}>
	MALLOC	mptr$3,16,<[:4,[:4,:4,:4]]>
	MOV	DWORD PTR [EAX+0],3
	MOV	EBX,EAX
	MOV	DWORD PTR [EBX+4],subsume(<B4>,1)
	MOV	DWORD PTR [EBX+8],subsume(<B4>,1)
	MOV	DWORD PTR [EBX+12],subsume(<B4>,1)
	FORGETUNIQUE	mptr$3
	PUSH	array(4,0,<B4^rw>,forgetname(EBX))
	MOV	ECX, [ESP+0]
	MOV	EBX,1
	ADD	EBX,1
;	static array bounds check: known index, constant array length
	MOV	ECX, [ECX+4*EBX+4]
	PUSH	subsume(<B4>,0)
	PUSH	0
	JMP	fortest$4
forbody$5:
LABELTYPE <All[s1:Ts s2:Ts cg:Tt i$9:Sint | i$9<3 ].code {TLA: ^*[cg^rw],EBP: sptr (?E s2 cg),ESP: sptr S(i$9)::B4::(?ua B4 3)::(?Sv s1 s2 cg)@(?E s2 cg)}>
	MOV	EBX,[ESP+0]
	MOV	EAX,[ESP+8]
;	static array bounds check: uses loop invariant i$9 < 3
	MOV	EBX,[EAX+4*EBX+4]
	MOV	EAX,[ESP+4]
	ADD	EAX,EBX
	MOV	[ESP+4],EAX
forcount$6:
	PUSH	subsume(<B4>,1)
	MOV	EAX,[ESP+4]
	INC	EAX
	MOV	[ESP+4],EAX
	POP	EBX
	SUB	EAX,EBX
fortest$4:
	MOV	EAX,[ESP+8]
	MOV	ECX,[EAX+0]
	MOV	EAX,[ESP+0]
; 	establish loop invariant i$10 < 3  
;	(abstract the loop counter and do an *unsigned* test)
	UNPACK  i$10,EAX,EAX
	MOV	[ESP+0],EAX
	CMP	EAX,ECX
	JB	prove(tapp(forbody$5,<s1,s2,cg,i$10>))
forend$7:
	; either we pack up the integer or we leave it unpacked but put
	; a label type on fortest$11.  We must abstract the value of the
	; index so the two entries to fortest$11 look the same.  Otherwise
	; the values would be 0 and (i$9+1).  I chose to pack it up with
	; the relevant information (0 <=# index).
	MOV	DWORD PTR [ESP+0],pack(<0>,0,<Exist[i$10:Sint | 0 <=# i$10].S(i$10)>)
	JMP	fortest$11
forbody$12:
LABELTYPE <All[s1:Ts s2:Ts cg:Tt i$9:Sint | i$9 <# 3 && 0 <=# i$9 ].code {TLA: ^*[cg^rw],EBP: sptr (?E s2 cg),ESP: sptr S(i$9)::B4::(?ua B4 3)::(?Sv s1 s2 cg)@(?E s2 cg)}>
	MOV	EAX,[ESP+8]		; mov array into EAX
	MOV	EBX,[ESP+0]  	        ; mov index into EBX
					; invariant: i$9 <# 3  && 0 <=# i$9
	PROOF	<array1<i$9,3>>		; use invariant to prove i$9 <u 3
	MOV	EBX,[EAX+4*EBX+4]	; static bounds check
	MOV	EAX,[ESP+4]
	ADD	EAX,EBX
	MOV	[ESP+4],EAX
forcount$13:
;	dead code in the increment eliminated for clarity
	MOV 	EAX,[ESP+0]		; EAX : S(i$9)
	INC	EAX			; EAX : S(i$9 ++ 1)
	PROOF	<array3<i$9,3>>		; use invariant to prove 0 <=# i$9 ++ 1
	COERCE	pack(<i$9++1>,EAX,<Exist[i$10:Sint | 0 <=# i$10].S(i$10)>)
	MOV	[ESP+0],EAX
fortest$11:
	MOV	EAX,[ESP+8]
	MOV	ECX,[EAX+0]
	UNPACK	i$11,EAX,[ESP+0]	; invariant1: 0 <=# i$11
	MOV	[ESP+0],EAX
	CMP	EAX,ECX
; 	use invariant1 and the loop test i$11 <# 3 to prove code precondition
	JL	prove(tapp(forbody$12,<s1,s2,cg,i$11>)) 
forend$14:
	COERCE	pack(<3>,[ESP+8],<?arr B4>)
	MOV	DWORD PTR [ESP+0],subsume(<B4>,0)
	JMP	fortest$18
forbody$19:
LABELTYPE <All[s1:Ts s2:Ts cg:Tt].code {TLA: ^*[cg^rw],EBP: sptr (?E s2 cg),ESP: sptr B4::B4::(?arr B4)::(?Sv s1 s2 cg)@(?E s2 cg)}>
	MOV	EBX,[ESP+0]
	MOV	EAX,[ESP+8]
	UNPACK	?sz$22,EAX,EAX
	UNPACK	i$23,EBX,EBX
	CMP	EBX,[EAX+0]
	JAE	_array_bounds_error
	MOV	EBX,[EAX+4*EBX+4]
	MOV	EAX,[ESP+4]
	ADD	EAX,EBX
	MOV	[ESP+4],EAX
forcount$20:
	PUSH	subsume(<B4>,1)
	MOV	EAX,[ESP+4]
	INC	EAX
	MOV	[ESP+4],EAX
	POP	EBX
	SUB	EAX,EBX
fortest$18:
	MOV	EAX,[ESP+8]
	UNPACK	?sz$24,EAX,EAX
	MOV	ECX,subsume(<B4>,[EAX+0])
	MOV	EAX,[ESP+0]
	CMP	EAX,ECX
	JL	tapp(forbody$19,<s1,s2,cg>)
forend$21:
	ADD	ESP,4
	PUSH	DWORD PTR [ESP+0]
	CALL	tapp(_Core?print_int,<ESP 1 4 s1,EBP 1,cg>)
	ADD	ESP,12
	RETN
_tal_main:
LABELTYPE <code {TLA: ^*[te^rw,B4^rw,B4^rw,B4^rw],ESP: sptr se}>
	PUSH	_pop_exn_handler
	MOV	EBP,ESP
	CALL	tapp(__main$,<se,se,te>)
	POP	EBX
	PUSH	0
	JMP	tapp(_tal_exit,<se>)

	DATA

	_end_TAL
	END
