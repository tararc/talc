; TAL IMPLEMENTATION check_array3
; This file was generated by TALC
	INCLUDE	TAL.INC
	_begin_TAL


	TAL_IMPORT	pop_runtime.tali
	TAL_IMPORT	opt_array2_i.tali

	TAL_EXPORT	tal_prog.tali
	TAL_EXPORT	opt_array2_e.tali

	TYPE	<bogus_option$1 :T4 = ^T[0]>

	CODE

__main$:
LABELTYPE <All[s1:Ts s2:Ts cg:Tt].code {TLA: ^*[cg^rw],EBP: sptr (?E s2 cg),ESP: sptr (?Sv s1 s2 cg)@(?E s2 cg)}>
	MALLOC	mptr$3,16,<[:4,[:4,:4,:4]]>
	MOV	DWORD PTR [EAX+0],3
	MOV	EBX,EAX
	MOV	DWORD PTR [EBX+4],subsume(<B4>,1)
	MOV	DWORD PTR [EBX+8],subsume(<B4>,1)
	MOV	DWORD PTR [EBX+12],subsume(<B4>,1)
	FORGETUNIQUE	mptr$3
; 	An ascending loop that uses index arithmetic (unsigned test)
	COERCE	array(4,0,<B4^rw>,forgetname(EBX)) ; EBX: unpacked array
	MOV 	ECX,4                              ; ECX: index*#4 ++ 4
	COERCE  pack(<0>,ECX,<Exist[i$10:Sint | 4*#i$10<16].S(4*#i$10++4)>)
	MOV 	EAX,16                             ; EAX: length*#4 ++ 4
	MOV	EDX,subsume(<B4>,0)                ; EDX: sum so far          
	JMP	fortest$4
forbody$5:
LABELTYPE <All[s1:Ts s2:Ts cg:Tt i$9:Sint | 4*#i$9++4<16 && 4*#i$9<16].code {TLA: ^*[cg^rw],EBP: sptr (?E s2 cg),ECX:S(4*#i$9++4),EBX:?ua B4 3,EAX:S(16),EDX:B4,ESP: sptr (?Sv s1 s2 cg)@(?E s2 cg)}>
;	static array bounds check
	PROOF	<ltu_to_lteu<4*#i$9,16> translteu<4*#i$9,16,1073741819> minusltu<4*#i$9,12,4>>
	ADD	EDX,[EBX+ECX]
forcount$6:
	ADD	ECX,4
	COERCE	pack(<i$9++1>,ECX,<Exist[i$10:Sint | 4*#i$10<16].S(4*#i$10++4)>)
fortest$4:
	UNPACK  i$10,ECX,ECX
	CMP	ECX,EAX
	JB	prove(tapp(forbody$5,<s1,s2,cg,i$10>))
forend$7:
;	Remove all conjuncts from context
	PROOF	<empty<>>
; 	A descending loop that uses index arithmetic (unsigned test)
	MOV	ECX, 12		; initial loop index
	MOV 	EAX, 4		; loop bound 
	COERCE  pack(<2>,ECX,<Exist[i$10:Sint | 4*#i$10++4<16].S(4*#i$10++4)>)
	JMP	fortest$14
forbody$15:
LABELTYPE <All[s1:Ts s2:Ts cg:Tt i$9:Sint | 4 <= 4++4*#i$9 && 4*#i$9++4 < 16].code {TLA: ^*[cg^rw],EBP: sptr (?E s2 cg),ECX:S(4*#i$9++4),EBX:?ua B4 3,EAX:S(4),EDX:B4,ESP: sptr (?Sv s1 s2 cg)@(?E s2 cg)}>
;	static array bounds check
	PROOF   <array4<4,4*#i$9,16>>
	PROOF	<ltu_to_lteu<4*#i$9,16> translteu<4*#i$9,16,1073741819> minusltu<4*#i$9,12,4>>
	ADD	EDX,[EBX+ECX]
forcount$16:
	SUB	ECX,4
	COERCE	pack(<i$9 - 1>,ECX,<Exist[i$10:Sint | 4*#i$10++4<16].S(4*#i$10++4)>)
fortest$14:
	UNPACK  i$12,ECX,ECX
	CMP	ECX,EAX
	JAE	prove(tapp(forbody$15,<s1,s2,cg,i$12>))
forend$17:
	RETN
_tal_main:
LABELTYPE <code {TLA: ^*[te^rw,B4^rw,B4^rw,B4^rw],ESP: sptr se}>
	PUSH	_pop_exn_handler
	MOV	EBP,ESP
	CALL	tapp(__main$,<se,se,te>)
	POP	EBX
	PUSH	0
	JMP	tapp(_tal_exit,<se>)

	DATA

	_end_TAL
	END
