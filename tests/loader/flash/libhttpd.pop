/* library includes */
#include "unixlib.h"
#include "core.h"
#include "string.h"
#include "buffer.h"

/* flash webserver includes */
#include "config.h"
#include "version.h"
#include "conn.h"
#include "handy.h"
#include "c_string.h"
#include "maint.h"

/* we have to calculate the string length each time here, but
   it should prevent us from having to reuse strings */
#define ADDS(s) Buffer::add_substring(buf,s,0,C_strlen(s))
/* when we are darn SURE that this is a popcorn-style string */
#define ADDFS(s) Buffer::add_string(buf,s)
#define ADDI(i,w) Buffer::add_string(buf,string_of_int_width(i,w))
#define ADDC(c) Buffer::add_char(buf,c)
#define ADDB(b) Buffer::add_buffer(buf,b)
#define CONTENTS() Buffer::contents(buf)

open Core;

/* GLOBALS */

string methodStrings[NUM_METHODS];

/* extern void TimeEnd(string); */
FILE timingFile;
#define TIMINGFILENAME "/tmp/timingfile"

struct httpd_server {
  <string>Opt hostname;
  int port;
  <string>Opt cgi_pattern;
  string cwd;
  int fd;
  /* for updates */
  int maint_port;
  int maint_fd;
}

static int /* inet_addr */ host_addr;
int defaultSendBufSize;

static int scrambledNumbers[256];

httpd_server HS = ^httpd_server(null,0,null,"",-1,0,-1);

timeval globalTimeOfDay = ^timeval(0,0);
string globalTimeOfDayStr = "1234567890123456789012345678901234567890";

/* ---------------------------------------------------------------- */
int
GenericStringHash(string str)
{
  int val;
  int i, j, k;

  j = 0;
  val = 0;

  for (i=0; i<size(str); i++) {
    k = (j + str[i]) & 0xff;
    j += 163;                   /* some prime number */
    val += scrambledNumbers[i];
  }
  return(val);
}

/* ---------------------------------------------------------------- */
static string monthNames[] = {
  "Jan", "Feb", "Mar", "Apr",
  "May", "Jun", "Jul", "Aug",
  "Sep", "Oct", "Nov", "Dec"};
static string dayNames[] = {
  "Sun", "Mon", "Tue",
  "Wed", "Thu", "Fri", "Sat"};
void
MakeHTTPDate(Buffer::t buf, int unixTime)
{
  /* date generated by this function will be constant-length.
     if it's not, very bad things can happen */

  tm gmt;

  gmt = unix_gmtime(unixTime);

  /*
  buf = sprintf("%s, %.2d %s %d %.2d:%.2d:%.2d GMT",
          dayNames[gmt.tm_wday],
          gmt.tm_mday, monthNames[gmt.tm_mon], gmt.tm_year + 1900,
          gmt.tm_hour, gmt.tm_min, gmt.tm_sec);
  */
  
  ADDFS(dayNames[gmt.tm_wday]);
  ADDFS(", ");
  ADDI(gmt.tm_mday,2);
  ADDC(' ');
  ADDFS(monthNames[gmt.tm_mon]);
  ADDC(' ');
  ADDI(gmt.tm_year + 1900,0);
  ADDC(' ');
  ADDI(gmt.tm_hour,2);
  ADDC(':');
  ADDI(gmt.tm_min,2);
  ADDC(':');
  ADDI(gmt.tm_sec,2);
  ADDFS(" GMT");
}
/* ---------------------------------------------------------------- */
static wait_flag flags[1] = { ^wait_flag.WNOHANG };
static void
ChildHandler(int sig)
{
  int pid;
  
  /* Reap defunct children until there aren't any more. */
  for (;;) {
    try {
      pid = unix_waitpid(flags,-1).1;
      if (pid == 0)		/* none left */
	break;
    } handle e {
      switch e {
	case Unix_error *(code,syscall):
	  switch (code) {
	  case EINTR:
	    continue;
	    /* ECHILD shouldn't happen with the WNOHANG option, but with
	    ** some kernels it does anyway.  Ignore it.
	    */
	  case ECHILD:
	    break; /* out of loop */
	  default:
	    fprintf(tal_stderr,"%s:%s\n",syscall,unix_error_string(code));
	    break; /* out of loop */
	  }
      }
    }	
  }

  /* reset the signal _after_ getting the kids - some systems
     seem to dislike it the other way around */

  /* XXX done automatically in the Unix library */
  /*
    signal(SIGCHLD, ChildHandler);  
  */
}
/* ---------------------------------------------------------------- */
bool
HttpdInitialize(<string>Opt hostname, int port, int maint_port,
                <string>Opt cgi_pattern, string cwd)
{
  /* string cp; */
  /* struct linger Ling; */
  host_entry he;
  sockaddr sa;
  int i;

  for (i = 0; i < 256; i++)
    scrambledNumbers[i] = random();

  methodStrings[METHOD_GET] = "GET";
  methodStrings[METHOD_POST] = "POST";
  methodStrings[METHOD_HEAD] = "HEAD";
  methodStrings[METHOD_ERROR] = "";

  /* Set up child-process reaper. 
  signal(SIGCHLD, ChildHandler);
  */

  /* XXX original duplicates the strings ... */
  HS.hostname = hostname;
  HS.port = port;
  /* HS.maint_port = maint_port; */
  if (cgi_pattern != null) {
    /* Nuke any leading slashes. */
    for (int i = 0; cgi_pattern.v[i] == '/'; i++);
    if (i == 0) 
      HS.cgi_pattern = cgi_pattern;
    else
      HS.cgi_pattern = 
	^Opt(String::substring(cgi_pattern.v,i,size(cgi_pattern.v)-i));
  }
  else
    HS.cgi_pattern = null;
  HS.cwd = cwd;

  /* Start the maintenance application */
  /*   want to do this before we open any more sockets in the app,
       and before we close stdin, etc. in main() */
  HS.maint_fd = StartMaintApp();  

  try {
    /* Create TCP listen socket. */
    HS.fd = unix_socket(^socket_domain.PF_INET, 
                        ^socket_type.SOCK_STREAM, 0);
    /* Create UDP maintenance socket. */
    /*
    HS.maint_fd = unix_socket(^socket_domain.PF_INET, 
                              ^socket_type.SOCK_DGRAM, 0);
    */
    /* HS.maint_fd = STDIN; */
    /* Allow reuse of local addresses. */
    unix_setsockopt(HS.fd, ^socket_option.SO_REUSEADDR, 1);
    /* unix_setsockopt(HS.maint_fd, ^socket_option.SO_REUSEADDR, 1); */
    
  /*  
  Ling.l_onoff = 0;
  Ling.l_linger = 0;
  
  if (setsockopt(HS.fd, SOL_SOCKET, SO_LINGER, (char *) &Ling, sizeof(Ling)))
    perror("linger");
  */

    defaultSendBufSize = unix_getsockopt(HS.fd, ^socket_option.SO_SNDBUF);
    if (sendBufSizeBytes <= defaultSendBufSize)
      sendBufSizeBytes = 0;

    /* Set the accept socket file descriptor to no-delay mode. */
    unix_set_nonblock(HS.fd);
    unix_set_nonblock(HS.maint_fd);
  
    /* Bind to it. */
    { int inet_addr;
      if (HS.hostname == null)
	inet_addr = INADDR_ANY;
      else {
	/* sa.sin_addr.s_addr = inet_addr(HS.hostname);
	   if ((int) sa.sin_addr.s_addr == -1) { */
	he = unix_gethostbyname(HS.hostname.v);
	if (he.h_addrtype != ^socket_domain.PF_INET)
	  raise (^Failure("non-IP network address"));
	inet_addr = he.h_addr;
      }
      sa = ^sockaddr.ADDR_INET(^(inet_addr,HS.port));
      host_addr = inet_addr;
    }
    unix_bind(HS.fd, sa);
    /* unix_bind(HS.maint_fd, sa); */

    /* Start a listen going. */
    unix_listen(HS.fd, LISTEN_BACKLOG);

    return false;
  } handle e {
    switch e {
    case Unix_error *(code,unix_call):
      printf("%s: %s\n",unix_call,unix_error_string(code));
      /* FreeHttpdServer(); */
      return true;
    default:
      raise (e);
    }
  }
}
/* ---------------------------------------------------------------- */
void
HttpdTerminate()
{
  unix_close(HS.fd);
  unix_close(HS.maint_fd);
}

/* ---------------------------------------------------------------- */
/* XXX TODO -- make special version of sprintf whose only argument is
   a single string (will go well with the format strings below) */
string ok200title = "OK";

string err302title = "Found";
string err302form = "The actual URL is '%.80s'.\n";

string err304title = "Not Modified";

string err400title = "Bad Request";
string err400form =  "Your request '%.80s' has bad syntax or is inherently impossible to satisfy.\n";

string err403title = "Forbidden";
string err403form =  "You do not have permission to get URL '%.80s' from this server.\n";

string err404title = "Not Found";
string err404form =  "The requested URL '%.80s' was not found on this server.\n";

string err408title = "Request Timeout";
string err408form =  "No request appeared within a reasonable time period.\n";

string err500title = "Internal Error";
string err500form =  "There was an unusual problem serving the requested URL '%.80s'.\n";

string err501title = "Not Implemented";
string err501form =  "The requested method '%.80s' is not implemented by this server.\n";

string httpd_err503title = "Service Temporarily Overloaded";
string httpd_err503form =  "The requested URL '%.80s' is temporarily overloaded.  Please try again later.\n";

/* ---------------------------------------------------------------- */
/* specialized version of sprintf for one string argument */
/* assumes the form is a pop-style string, while the arg could
   be c-style one (and thus needs C_strlen) */
static void
FillForm(Buffer::t buf, string form, string arg)
{
  int i, len;
  bool skipNext, didIt = false;
outer:
  for (i=0, len=size(form), skipNext = false; i<len; i++) {
    if (skipNext) {
      skipNext = false;
      continue;
    }
    switch (form[i]) {
    case '\\':
      skipNext = true;
    case '%': {
      int maxWidth = 0;
      int idx = i;
      /* look for any spacing flags */
      if (form[i+1] == '.') {
	string tmp;
	int j, field_len;
	for (j = i+2; j<len && form[j] != 's'; j++) 
	  if (form[j] < '0' || form[j] > '9')
	    continue outer;
	field_len = j - (i+2);
	if (field_len > 0) {
	  tmp = new_string(field_len);
	  for (int k = 0; k<field_len; k++)
	    tmp[k] = form[k+i+2];
	  maxWidth = int_of_string(tmp);
	  i += (2+field_len);
	}
      }
      else
	i++;
      /* make sure this is a %s filler */
      if (form[i] != 's') {
	fprintf(tal_stderr,"FillForm: %% code is |%c|\n",form[i]);
	raise (^Failure("FillForm: wrong code for %"));
      }
      /* add the first part of the form */
      /*
      printf("Adding substring, ofs=%d, len=%d, (=|%c|-|%c|)\n",0,idx,
	     form[0],form[(idx-1) > 0 ? idx-1 : 0]);
      */
      Buffer::add_substring(buf,form,0,idx);
      /* add in the argument */
      if (maxWidth > 0) {
	Buffer::add_substring(buf,arg,0,MIN(maxWidth,C_strlen(arg)));
      }
      else
	Buffer::add_substring(buf,arg,0,C_strlen(arg));

      /* add remaining part of form */
      /*
      printf("Adding substring, ofs=%d, len=%d, (=|%c|-|%c|)\n",
	     i+1, len-(i+1), form[i+1], form[len-1]);
      */
      Buffer::add_substring(buf,form,i+1,len-(i+1));
      didIt = true;
      break; /* out of loop */
    }
    default: ; /* continue */
    }
  }
  if (!didIt) {
    fprintf(tal_stderr,"FillForm: didn't find a %%s arg in string\n");
    raise (^Failure("FillForm: didn't find a %s arg in string"));
  }
}

/* ---------------------------------------------------------------- */
void
SendMime(Buffer::t buf, httpd_conn hc, int status, string title, 
	 string encodings, string extraheads, string type, int length, 
	 int mod)
{
  string enc_head = "\nContent-Encoding: ";
  /*
  char tbuf[100];
  char buf[1000];
  char conLenInfo[40];
  */
  string sbuf;
  
  if ((size(encodings) == 0) || (encodings[0] == '\000'))
    encodings = enc_head = "";

  hc.hc_status = status;
  if (hc.hc_mimeFlag) {
    if (mod == 0)
      mod = unix_time();

    /*
    buf =
      sprintf(
	    "HTTP/1.0 %d %s\n"
	    "Date: %s\n"
	    "Server: %s%s%s%s%s\n"
	    "Content-Type: %s%s\n"
	    "Last-Modified: %s\n\n",
	    status, title, 
	    globalTimeOfDayStr,
	    SERVER_SOFTWARE,
	    enc_head, encodings, 
	    extraheads[0] != '\000' ? "\n" : "", extraheads,
	    type, conLenInfo, Buffer::contents(tbuf));
    */
    ADDFS("HTTP/1.0 ");
    ADDI(status,0);
    ADDC(' ');
    ADDS(title);
    ADDFS("\nDate: ");
    ADDS(globalTimeOfDayStr);
    ADDFS("\nServer: ");
    ADDFS(SERVER_SOFTWARE);
    ADDS(enc_head);
    ADDS(encodings);
    if ((size(extraheads) != 0) && (extraheads[0] != '\000')) {
      ADDC('\n');
      ADDS(extraheads);
    }
    ADDFS("\nContent-Type: ");
    ADDS(type);
    if (length >= 0) {
      ADDS("\nContent-Length: ");
      ADDI(length,0);
    }
    ADDFS("\nLast-Modified: ");
    MakeHTTPDate(buf, mod);
    ADDFS("\n\n");

    sbuf = CONTENTS();
    fprintf(tal_stderr,"SendMime: writing |%s|\n",sbuf);
    unix_write(hc.hc_fd, sbuf, 0, size(sbuf));
  }
}
/* ---------------------------------------------------------------- */
static int
SendAddress(Buffer::t buf, httpd_conn hc)
{
  string sbuf;
  
  ADDFS("<ADDRESS><A HREF=\"");
  ADDFS(SERVER_ADDRESS);
  ADDFS("\">");
  ADDFS(SERVER_SOFTWARE);
  ADDFS("</A></ADDRESS>\n");
  /*
  buf = sprintf("<ADDRESS><A HREF=\"%s\">%s</A></ADDRESS>\n",
		SERVER_ADDRESS, SERVER_SOFTWARE);
  */
  sbuf = CONTENTS();
  unix_write(hc.hc_fd, sbuf, 0, size(sbuf));
  return size(sbuf);
}
/* ---------------------------------------------------------------- */
static void
SendResponse(Buffer::t buf, httpd_conn hc, int status, string title, 
	     string extrahead, string form, string arg)
{
  string sbuf;

  SendMime(buf, hc, status, title, "", extrahead, "text/html", -1, 0);
  Buffer::clear(buf);

  /*
  buf = sprintf(
	  "<HTML><HEAD><TITLE>%d %s</TITLE></HEAD>\n<BODY><H2>%d %s</H2>\n",
	  status, title, status, title);
  */

  ADDFS("<HTML><HEAD><TITLE>");
  ADDI(status,0);
  ADDC(' ');
  ADDS(title);
  ADDFS("</TITLE></HEAD>\n<BODY><H2>");
  ADDI(status,0);
  ADDC(' ');
  ADDS(title);
  ADDFS("</H2>\n");
  sbuf = CONTENTS();
  unix_write(hc.hc_fd, sbuf, 0, size(sbuf));
  Buffer::clear(buf);

  FillForm(buf, form, arg);
  sbuf = CONTENTS();
  unix_write(hc.hc_fd, sbuf, 0, size(sbuf));
  Buffer::clear(buf);

  unix_write(hc.hc_fd, "<HR>\n", 0, 5);

  SendAddress(buf,hc);

  unix_write(hc.hc_fd, "</BODY></HTML>\n", 0, 15);
}
/* ---------------------------------------------------------------- */
void
HttpdSendErr(httpd_conn hc, int status, string title, string form, string arg)
{
  Buffer::t buf;
  buf = Buffer::create(1000);
  SendResponse(buf, hc, status, title, "", form, arg);
}
/* ---------------------------------------------------------------- */
static string headstr = "Location: ";
static string location;
static string header;
void
SendDirRedirect(httpd_conn hc)
{
  Buffer::t buf;

  location = realloc_str(location, C_strlen(hc.hc_encodedurl)+1);
  C_strcpy(location,hc.hc_encodedurl);
  C_strcat(location,"/");

  header = realloc_str(header, size(headstr) + C_strlen(location));
  C_strcpy(header,headstr);
  C_strcat(header,location);
  
  buf = Buffer::create(1000);

  SendResponse(buf, hc, 302, err302title, header, err302form, location);
}
/* ---------------------------------------------------------------- */
string
HttpdMethodStr(int method)
{
  return methodStrings[method];
}
/* ---------------------------------------------------------------- */
static bool inited = false;
static int n = 0;
int
HttpdGetNFiles()
{
  if (! inited) {
#define rlim_cur 1
#define rlim_max 2
    *(int,int) rl = ^(0,0);
    try {
      unix_getrlimit(^rlimit_resource.RLIMIT_NOFILE, rl);
      if (rl.rlim_max == RLIM_INFINITY)
	rl.rlim_cur = 4096;		/* arbitrary */
      else
	rl.rlim_cur = rl.rlim_max;
      unix_setrlimit(^rlimit_resource.RLIMIT_NOFILE, rl);
    } handle e {
      switch e {
      case Unix_error *(code,syscall):
	fprintf(tal_stderr,"%s:%s\n",syscall,unix_error_string(code));
	exit(1);
      }
    }
    n = rl.rlim_cur;
    /* if we don't have rlimit, use this 
    n = getdtablesize();
    */
    inited = true;
  }
  return n;
}
/* ---------------------------------------------------------------- */
void printConn(httpd_conn c)
{
  fprint_string(tal_stderr,"Connection:\n");
  fprintf(tal_stderr,"  hc_cnum=%d\n",c.hc_cnum);
  fprintf(tal_stderr,"  hc_clientAddr=%d\n",c.hc_clientAddr);
  fprintf(tal_stderr,"  hc_method=%d\n",c.hc_method);
  fprintf(tal_stderr,"  hc_status=%d\n",c.hc_status);
  fprint_string(tal_stderr,"  hc_encodedurl=");
  C_fprint_string(tal_stderr,c.hc_encodedurl,0);
  fprint_char(tal_stderr,'\n');
  fprint_string(tal_stderr,"  hc_protocol=");
  C_fprint_string(tal_stderr,c.hc_protocol,0);
  fprint_char(tal_stderr,'\n');
  fprint_string(tal_stderr,"  hc_cookie=");
  C_fprint_string(tal_stderr,c.hc_cookie,0);
  fprint_char(tal_stderr,'\n');
  fprint_string(tal_stderr,"  hc_contentType=");
  C_fprint_string(tal_stderr,c.hc_contentType,0);
  fprint_char(tal_stderr,'\n');
  fprint_string(tal_stderr,"  hc_referer=");
  C_fprint_string(tal_stderr,c.hc_referer,0);
  fprint_char(tal_stderr,'\n');
  fprint_string(tal_stderr,"  hc_userAgent=");
  C_fprint_string(tal_stderr,c.hc_userAgent,0);
  fprint_char(tal_stderr,'\n');
  fprint_string(tal_stderr,"  hc_accept=");
  C_fprint_string(tal_stderr,c.hc_accept,0);
  fprint_char(tal_stderr,'\n');
  fprint_string(tal_stderr,"  hc_accepte=");
  C_fprint_string(tal_stderr,c.hc_accepte,0);
  fprint_char(tal_stderr,'\n');
  fprintf(tal_stderr,"  hc_ifModifiedSince=%d\n",c.hc_ifModifiedSince);
  fprintf(tal_stderr,"  hc_contentLength=%d\n",c.hc_contentLength);
  fprintf(tal_stderr,"  hc_mimeFlag=%s\n",c.hc_mimeFlag? "true" : "false");
  fprintf(tal_stderr,"  hc_fd=%d\n",c.hc_fd);
  fprintf(tal_stderr,"  hc_isPersistentConnection=%s\n",
	  c.hc_isPersistentConnection? "true" : "false");
  fprintf(tal_stderr,"  hc_expirationTime=%d\n",c.hc_expirationTime);
  fprintf(tal_stderr,"  hc_timerPrivate=%d\n",c.hc_timerPrivate);
  fprintf(tal_stderr,"  hc_sndbuf=%d\n",c.hc_sndbuf);
  fprintf(tal_stderr,"  hc_bytesSent=%d\n",c.hc_bytesSent);
  fprint_string(tal_stderr,"  hc_stripped=");
  C_fprint_string(tal_stderr,c.hc_stripped,0);
  fprint_char(tal_stderr,'\n');
  fprintf(tal_stderr,"  hc_nagleOff=%s\n",c.hc_nagleOff? "true" : "false");
  fprint_char(tal_stderr,'\n');
}
/*
float
DiffTime(struct timeval *start, struct timeval *end)
{
  float temp;

  temp = (end->tv_sec - start->tv_sec) + 
    1e-6 * (end->tv_usec - start->tv_usec);
  return(temp);
}
*/
/* ---------------------------------------------------------------- */
